
#include "AuthWindow.hpp"
#include "User.hpp"
#include "Game.hpp"
#include "Records.hpp"
#include <iostream>
#include <stdexcept>
#include <filesystem>

using namespace std;
namespace fs = std::filesystem;

AuthWindow::AuthWindow() : window(sf::VideoMode::getFullscreenModes()[0], "Authorization", sf::Style::Fullscreen),
    currentState(WindowState::MAIN), isUsernameActive(false), isPasswordActive(false), isPasswordVisible(false),
    cursorBlinkTime(0), showCursor(true), selectedMap(1),
    isDraggingMusicSlider(false), isDraggingEffectsSlider(false), selectedCharacter(0) {
    
    try {
        // Initialize text rendering settings
        sf::ContextSettings settings;
        settings.antialiasingLevel = 8;
        window.create(sf::VideoMode::getFullscreenModes()[0], "Authorization", sf::Style::Fullscreen, settings);
        
        window.setFramerateLimit(60);
        
        // Load font with error handling
        string fontPath = "/System/Library/Fonts/Supplemental/Arial Black.ttf";
        if (!fs::exists(fontPath)) {
            fontPath = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf";
            if (!fs::exists(fontPath)) {
                throw runtime_error("Could not find DejaVu Sans font in standard locations");
            }
        }
        
        if (!font.loadFromFile(fontPath)) {
            throw runtime_error("Failed to load font file");
        }
        
        // Debug information
        std::cout << "Font loaded successfully from: " << fontPath << std::endl;
        std::cout << "Font info - Line spacing: " << font.getLineSpacing(30) << std::endl;
        std::cout << "Font info - Underline position: " << font.getUnderlinePosition(30) << std::endl;
        std::cout << "Font info - Underline thickness: " << font.getUnderlineThickness(30) << std::endl;
        
        // Test text rendering
        sf::Text testText;
        testText.setFont(font);
        testText.setString("Тест русского текста");
        testText.setCharacterSize(30);
        testText.setFillColor(sf::Color::White);
        std::cout << "Test text bounds - Width: " << testText.getGlobalBounds().width 
                  << ", Height: " << testText.getGlobalBounds().height << std::endl;
        
        // Load music tracks
        if (!musicTracks[0].openFromFile("/Users/misa/Desktop/курсовая основа/sounds/ganggang.ogg")) {
             cerr << "Failed to load music track 1!" << endl;
        } else { cout << "Successfully loaded music track 1." << endl; }
        if (!musicTracks[1].openFromFile("/Users/misa/Desktop/курсовая основа/sounds/Lil-Pump-Esskeetit.ogg")) {
             cerr << "Failed to load music track 2!" << endl;
        } else { cout << "Successfully loaded music track 2." << endl; }
        if (!musicTracks[2].openFromFile("/Users/misa/Desktop/курсовая основа/sounds/zeze.ogg")) {
             cerr << "Failed to load music track 3!" << endl;
        } else { cout << "Successfully loaded music track 3." << endl; }
        if (!musicTracks[3].openFromFile("/Users/misa/Desktop/курсовая основа/sounds/makanishe.ogg")) {
             cerr << "Failed to load music track 4!" << endl;
        } else { cout << "Successfully loaded music track 4." << endl; }

        // Set initial volume and looping for all tracks
        for (int i = 0; i < 4; ++i) {
            musicTracks[i].setVolume(musicVolume);
            musicTracks[i].setLoop(true);
        }

        // Восстанавливаем состояние музыки
        if (currentTrack >= 0 && currentTrack < 4) {
            // Останавливаем все треки
            for (int i = 0; i < 4; ++i) {
                musicTracks[i].stop();
            }
            // Устанавливаем громкость и запускаем текущий трек
            musicTracks[currentTrack].setVolume(musicVolume);
            if (isMusicPlaying) {
                musicTracks[currentTrack].play();
            }
        }
        
        // Get screen dimensions and calculate scaling
        sf::Vector2u screenSize = window.getSize();
        float scaleX = screenSize.x / static_cast<float>(WINDOW_WIDTH);
        float scaleY = screenSize.y / static_cast<float>(WINDOW_HEIGHT);
        
        // Setup background
        // Load background textures
        if (!backgroundTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/backgroung/back1.png")) {
            std::cerr << "Failed to load dark background texture for AuthWindow" << std::endl;
        }
        if (!lightBackgroundTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/backgroung/back2.png")) {
            std::cerr << "Failed to load light background texture for AuthWindow" << std::endl;
        }
        background.setSize(sf::Vector2f(screenSize.x, screenSize.y));
        background.setTexture(isDarkTheme ? &backgroundTexture : &lightBackgroundTexture);
        
        // Setup cursor
        cursor.setFont(font);
        cursor.setString("|");
        cursor.setCharacterSize(30 * scaleY);
        cursor.setFillColor(sf::Color::Black);
        cursor.setPosition(0, 0);
        
        // Initialize UI elements
        initializeUIElements();
        
        // Load button click sound
        if (!buttonClickBuffer.loadFromFile("/Users/misa/Desktop/курсовая основа/sounds effects/buttonSound.ogg")) {
            cerr << "Failed to load button click sound!" << endl;
        } else {
            cout << "Successfully loaded button click sound." << endl;
            buttonClickSound.setBuffer(buttonClickBuffer);
            buttonClickSound.setVolume(effectsVolume);
        }

        // Load key collect sound
        if (!keyCollectBuffer.loadFromFile("/Users/misa/Desktop/курсовая основа/sounds effects/sborKlucha.ogg")) {
            cerr << "Failed to load key collect sound!" << endl;
        } else {
            cout << "Successfully loaded key collect sound." << endl;
            keyCollectSound.setBuffer(keyCollectBuffer);
            keyCollectSound.setVolume(effectsVolume);
        }
        
        // Set text rendering quality
        for (auto& text : {&loginText, &registerText, &exitText, &characterText, &characterSelectText, 
                          &settingsText, &recordsText, &menuExitText, &settingsTitleText, 
                          &musicVolumeText, &effectsVolumeText, &currentTrackText, &themeColorText, 
                          &settingsBackText, &mapTitleText, &mapSelectText, &difficultyTitleText, 
                          &difficultySelectText, &startGameText, &mapBackText, &redCubeText, 
                          &greenCubeText, &blueCubeText, &usernameText, &passwordText, &submitText, 
                          &backText, &showPasswordText, &errorText, &highscoresBackText, 
                          &highscoresTitleText, &highscoresTableText}) {
            text->setStyle(sf::Text::Regular);
            text->setOutlineThickness(0);
        }
        
        // Load character textures
        if (!mikeLeftTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/cheracter/bear.png")) {
            cerr << "Failed to load Mike texture!" << endl;
        }
        if (!jesyLeftTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/cheracter/dino.png")) {
            cerr << "Failed to load Jesy texture!" << endl;
        }
        if (!gremLeftTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/cheracter/cat.png")) {
            cerr << "Failed to load Grem texture!" << endl;
        }

        // Setup character sprites
        mikeSprite.setTexture(mikeLeftTexture);
        mikeSprite.setOrigin(mikeLeftTexture.getSize().x / 2.0f, mikeLeftTexture.getSize().y / 2.0f);

        jesySprite.setTexture(jesyLeftTexture);
        jesySprite.setOrigin(jesyLeftTexture.getSize().x / 2.0f, jesyLeftTexture.getSize().y / 2.0f);

        gremSprite.setTexture(gremLeftTexture);
        gremSprite.setOrigin(gremLeftTexture.getSize().x / 2.0f, gremLeftTexture.getSize().y / 2.0f);

        // Scale sprites to appropriate size
        float spriteScale = 0.8f;
        mikeSprite.setScale(spriteScale, spriteScale);
        jesySprite.setScale(spriteScale, spriteScale);
        gremSprite.setScale(spriteScale, spriteScale);

        // Initialize character text
        mikeText.setFont(font);
        mikeText.setString(L"Медведь Мишаня");
        mikeText.setCharacterSize(24);
        mikeText.setFillColor(sf::Color::White);
        mikeText.setOrigin(mikeText.getLocalBounds().width / 2.0f, mikeText.getLocalBounds().height / 2.0f);

        jesyText.setFont(font);
        jesyText.setString(L"Динозавр Смола");
        jesyText.setCharacterSize(24);
        jesyText.setFillColor(sf::Color::White);
        jesyText.setOrigin(jesyText.getLocalBounds().width / 2.0f, jesyText.getLocalBounds().height / 2.0f);

        gremText.setFont(font);
        gremText.setString(L"Кот Зачет");
        gremText.setCharacterSize(24);
        gremText.setFillColor(sf::Color::White);
        gremText.setOrigin(gremText.getLocalBounds().width / 2.0f, gremText.getLocalBounds().height / 2.0f);

        // Initialize hover states
        isMikeHovered = false;
        isJesyHovered = false;
        isGremHovered = false;

        // Initialize highlight rectangle
        // Removed selectedCharacterHighlight initialization
        
    } catch (const exception& e) {
        cerr << "Error initializing AuthWindow: " << e.what() << endl;
        throw;
    }
}

void AuthWindow::initializeUIElements() {
    sf::Vector2u screenSize = window.getSize();
    float scaleX = screenSize.x / static_cast<float>(WINDOW_WIDTH);
    float scaleY = screenSize.y / static_cast<float>(WINDOW_HEIGHT);

    try {
        // Debug font information
        std::cout << "Initializing UI elements with font: " << (font.getInfo().family) << std::endl;
        
        float centerY = screenSize.y / 2.f;
        float centerX = screenSize.x / 2.f;
        float fieldWidth = 400 * scaleX;
        float fieldHeight = 50 * scaleY;
        float labelOffsetX = 160 * scaleX;
        float spacingY = 30 * scaleY;
        float buttonWidth = 300 * scaleX;
        float buttonHeight = 60 * scaleY;
        float menuButtonWidth = 450 * scaleX;
        float menuButtonHeight = 60 * scaleY;
        float menuSpacingY = 40 * scaleY;

        // --- MAIN WINDOW ---
        float mainStartY = centerY - (buttonHeight * 3 + menuSpacingY * 2) / 2;
        loginButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        loginButton.setPosition(centerX - buttonWidth/2, mainStartY);
        loginButton.setFillColor(sf::Color(70, 130, 180));
        loginButton.setOutlineThickness(3);
        loginButton.setOutlineColor(sf::Color::White);
        loginText.setFont(font);
        loginText.setString(L"Войти");
        loginText.setCharacterSize(36 * scaleY);
        loginText.setFillColor(sf::Color::White);
        
        // Debug login te
        
        loginText.setPosition(
            loginButton.getPosition().x + buttonWidth/2 - loginText.getGlobalBounds().width/2,
            loginButton.getPosition().y + buttonHeight/2 - loginText.getGlobalBounds().height/2
        );
        registerButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        registerButton.setPosition(centerX - buttonWidth/2, mainStartY + buttonHeight + menuSpacingY);
        registerButton.setFillColor(sf::Color(70, 130, 180));
        registerButton.setOutlineThickness(3);
        registerButton.setOutlineColor(sf::Color::White);
        registerText.setFont(font);
        registerText.setString(L"Регистрация");
        registerText.setCharacterSize(36 * scaleY);
        registerText.setFillColor(sf::Color::White);
        registerText.setPosition(
            registerButton.getPosition().x + buttonWidth/2 - registerText.getGlobalBounds().width/2,
            registerButton.getPosition().y + buttonHeight/2 - registerText.getGlobalBounds().height/2
        );
        exitButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        exitButton.setPosition(centerX - buttonWidth/2, mainStartY + (buttonHeight + menuSpacingY) * 2);
        exitButton.setFillColor(sf::Color(180, 70, 70));
        exitButton.setOutlineThickness(3);
        exitButton.setOutlineColor(sf::Color::White);
        exitText.setFont(font);
        exitText.setString(L"выход");
        exitText.setCharacterSize(36 * scaleY);
        exitText.setFillColor(sf::Color::White);
        exitText.setPosition(
            exitButton.getPosition().x + buttonWidth/2 - exitText.getGlobalBounds().width/2,
            exitButton.getPosition().y + buttonHeight/2 - exitText.getGlobalBounds().height/2
        );

        // --- MAIN MENU ---
        float menuStartY = centerY - (menuButtonHeight * 5 + menuSpacingY * 4) / 2;  // Adjusted for 5 buttons
        characterButton.setSize(sf::Vector2f(menuButtonWidth, menuButtonHeight));
        characterButton.setPosition(centerX - menuButtonWidth/2, menuStartY);
        characterButton.setFillColor(sf::Color(70, 130, 180));
        characterButton.setOutlineThickness(3);
        characterButton.setOutlineColor(sf::Color::White);
        characterText.setFont(font);
        characterText.setString(L"Играть");
        characterText.setCharacterSize(36 * scaleY);
        characterText.setFillColor(sf::Color::White);
        characterText.setPosition(
            characterButton.getPosition().x + menuButtonWidth/2 - characterText.getGlobalBounds().width/2,
            characterButton.getPosition().y + menuButtonHeight/2 - characterText.getGlobalBounds().height/2
        );

        // Add character selection button
        characterSelectButton.setSize(sf::Vector2f(menuButtonWidth, menuButtonHeight));
        characterSelectButton.setPosition(centerX - menuButtonWidth/2, menuStartY + menuButtonHeight + menuSpacingY);
        characterSelectButton.setFillColor(sf::Color(70, 130, 180));
        characterSelectButton.setOutlineThickness(3);
        characterSelectButton.setOutlineColor(sf::Color::White);
        characterSelectText.setFont(font);
        characterSelectText.setString(L"Выбрать персонажа");
        characterSelectText.setCharacterSize(36 * scaleY);
        characterSelectText.setFillColor(sf::Color::White);
        characterSelectText.setPosition(
            characterSelectButton.getPosition().x + menuButtonWidth/2 - characterSelectText.getGlobalBounds().width/2,
            characterSelectButton.getPosition().y + menuButtonHeight/2 - characterSelectText.getGlobalBounds().height/2
        );

        // Add settings button
        settingsButton.setSize(sf::Vector2f(menuButtonWidth, menuButtonHeight));
        settingsButton.setPosition(centerX - menuButtonWidth/2, menuStartY + (menuButtonHeight + menuSpacingY) * 2);
        settingsButton.setFillColor(sf::Color(70, 130, 180));
        settingsButton.setOutlineThickness(3);
        settingsButton.setOutlineColor(sf::Color::White);
        settingsText.setFont(font);
        settingsText.setString(L"Настройки");
        settingsText.setCharacterSize(36 * scaleY);
        settingsText.setFillColor(sf::Color::White);
        settingsText.setPosition(
            settingsButton.getPosition().x + menuButtonWidth/2 - settingsText.getGlobalBounds().width/2,
            settingsButton.getPosition().y + menuButtonHeight/2 - settingsText.getGlobalBounds().height/2
        );

        // Add records button
        recordsButton.setSize(sf::Vector2f(menuButtonWidth, menuButtonHeight));
        recordsButton.setPosition(centerX - menuButtonWidth/2, menuStartY + (menuButtonHeight + menuSpacingY) * 3);
        recordsButton.setFillColor(sf::Color(70, 130, 180));
        recordsButton.setOutlineThickness(3);
        recordsButton.setOutlineColor(sf::Color::White);
        recordsText.setFont(font);
        recordsText.setString(L"Таблица лидеров");
        recordsText.setCharacterSize(36 * scaleY);
        recordsText.setFillColor(sf::Color::White);
        recordsText.setPosition(
            recordsButton.getPosition().x + menuButtonWidth/2 - recordsText.getGlobalBounds().width/2,
            recordsButton.getPosition().y + menuButtonHeight/2 - recordsText.getGlobalBounds().height/2
        );

        // Add exit button
        menuExitButton.setSize(sf::Vector2f(menuButtonWidth, menuButtonHeight));
        menuExitButton.setPosition(centerX - menuButtonWidth/2, menuStartY + (menuButtonHeight + menuSpacingY) * 4);
        menuExitButton.setFillColor(sf::Color(180, 70, 70));
        menuExitButton.setOutlineThickness(3);
        menuExitButton.setOutlineColor(sf::Color::White);
        menuExitText.setFont(font);
        menuExitText.setString(L"Выход");
        menuExitText.setCharacterSize(36 * scaleY);
        menuExitText.setFillColor(sf::Color::White);
        menuExitText.setPosition(
            menuExitButton.getPosition().x + menuButtonWidth/2 - menuExitText.getGlobalBounds().width/2,
            menuExitButton.getPosition().y + menuButtonHeight/2 - menuExitText.getGlobalBounds().height/2
        );

        // Initialize settings menu elements
        float sliderWidth = 400 * scaleX;
        float sliderHeight = 20 * scaleY;
        float handleSize = 30 * scaleY;
        float settingsStartY = centerY - 200 * scaleY;

        // Settings title
        settingsTitleText.setFont(font);
        settingsTitleText.setString(L"Настройки");
        settingsTitleText.setCharacterSize(48 * scaleY);
        settingsTitleText.setFillColor(sf::Color::White);
        settingsTitleText.setPosition(centerX - settingsTitleText.getGlobalBounds().width/2, settingsStartY);

        // Music volume slider
        musicVolumeText.setFont(font);
        musicVolumeText.setString(L"Громкость музыки");
        musicVolumeText.setCharacterSize(30 * scaleY);
        musicVolumeText.setFillColor(sf::Color::White);
        musicVolumeText.setPosition(centerX - sliderWidth/2, settingsStartY + 80 * scaleY);

        musicSlider.setSize(sf::Vector2f(sliderWidth, sliderHeight));
        musicSlider.setPosition(centerX - sliderWidth/2, settingsStartY + 120 * scaleY);
        musicSlider.setFillColor(sf::Color(100, 100, 100));

        musicSliderHandle.setSize(sf::Vector2f(handleSize, handleSize));
        musicSliderHandle.setPosition(
            musicSlider.getPosition().x + (musicVolume / 100.0f) * (sliderWidth - handleSize),
            musicSlider.getPosition().y - (handleSize - sliderHeight) / 2
        );
        musicSliderHandle.setFillColor(sf::Color::White);

        // Effects volume slider
        effectsVolumeText.setFont(font);
        effectsVolumeText.setString(L"Громкость эффектов");
        effectsVolumeText.setCharacterSize(30 * scaleY);
        effectsVolumeText.setFillColor(sf::Color::White);
        effectsVolumeText.setPosition(centerX - sliderWidth/2, settingsStartY + 200 * scaleY);

        effectsSlider.setSize(sf::Vector2f(sliderWidth, sliderHeight));
        effectsSlider.setPosition(centerX - sliderWidth/2, settingsStartY + 240 * scaleY);
        effectsSlider.setFillColor(sf::Color(100, 100, 100));

        effectsSliderHandle.setSize(sf::Vector2f(handleSize, handleSize));
        effectsSliderHandle.setPosition(
            effectsSlider.getPosition().x + (effectsVolume / 100.0f) * (sliderWidth - handleSize),
            effectsSlider.getPosition().y - (handleSize - sliderHeight) / 2
        );
        effectsSliderHandle.setFillColor(sf::Color::White);

        // Track selection buttons
        float trackButtonWidth = 60 * scaleX;
        float trackButtonHeight = 60 * scaleY;
        float trackButtonSpacing = 20 * scaleX;

        prevTrackButton.setSize(sf::Vector2f(trackButtonWidth, trackButtonHeight));
        prevTrackButton.setPosition(centerX - trackButtonWidth - trackButtonSpacing - 150 * scaleX, settingsStartY + 280 * scaleY);
        prevTrackButton.setFillColor(sf::Color(70, 130, 180));
        prevTrackButton.setOutlineThickness(3);
        prevTrackButton.setOutlineColor(sf::Color::White);

        nextTrackButton.setSize(sf::Vector2f(trackButtonWidth, trackButtonHeight));
        nextTrackButton.setPosition(centerX + 150 * scaleX + trackButtonSpacing, settingsStartY + 280 * scaleY);
        nextTrackButton.setFillColor(sf::Color(70, 130, 180));
        nextTrackButton.setOutlineThickness(3);
        nextTrackButton.setOutlineColor(sf::Color::White);

        // Current track text
        currentTrackText.setFont(font);
        currentTrackText.setString(L"Трек " + std::to_wstring(currentTrack + 1));
        currentTrackText.setCharacterSize(30 * scaleY);
        currentTrackText.setFillColor(sf::Color::White);
        currentTrackText.setPosition(
            centerX - currentTrackText.getGlobalBounds().width/2,
            settingsStartY + 280 * scaleY + trackButtonHeight/2 - currentTrackText.getGlobalBounds().height/2
        );

        // Theme color button
        themeColorButton.setSize(sf::Vector2f(300 * scaleX, 60 * scaleY));
        themeColorButton.setPosition(centerX - 150 * scaleX, settingsStartY + 400 * scaleY);
        themeColorButton.setFillColor(sf::Color(70, 130, 180));
        themeColorButton.setOutlineThickness(3);
        themeColorButton.setOutlineColor(sf::Color::White);

        themeColorText.setFont(font);
        themeColorText.setString(L"Тёмная");  // Initial text for dark theme
        themeColorText.setCharacterSize(30 * scaleY);
        themeColorText.setFillColor(sf::Color::White);
        themeColorText.setPosition(
            themeColorButton.getPosition().x + themeColorButton.getSize().x/2 - themeColorText.getGlobalBounds().width/2,
            themeColorButton.getPosition().y + themeColorButton.getSize().y/2 - themeColorText.getGlobalBounds().height/2
        );

        // Back button
        settingsBackButton.setSize(sf::Vector2f(300 * scaleX, 60 * scaleY));
        settingsBackButton.setPosition(centerX - 150 * scaleX, settingsStartY + 480 * scaleY);
        settingsBackButton.setFillColor(sf::Color(180, 70, 70));
        settingsBackButton.setOutlineThickness(3);
        settingsBackButton.setOutlineColor(sf::Color::White);

        settingsBackText.setFont(font);
        settingsBackText.setString(L"Вернуться в меню");
        settingsBackText.setCharacterSize(30 * scaleY);
        settingsBackText.setFillColor(sf::Color::White);
        settingsBackText.setPosition(
            settingsBackButton.getPosition().x + settingsBackButton.getSize().x/2 - settingsBackText.getGlobalBounds().width/2,
            settingsBackButton.getPosition().y + settingsBackButton.getSize().y/2 - settingsBackText.getGlobalBounds().height/2
        );

        // --- MAP SELECTION ---
        mapTitleText.setFont(font);
        mapTitleText.setString(L"Выбор карты");
        mapTitleText.setCharacterSize(48 * scaleY);
        mapTitleText.setFillColor(sf::Color::White);
        mapTitleText.setPosition(centerX - mapTitleText.getGlobalBounds().width/2, centerY - 200 * scaleY);
        mapSelectButton.setSize(sf::Vector2f(400 * scaleX, 60 * scaleY));
        mapSelectButton.setPosition(centerX - 200 * scaleX, centerY - 50 * scaleY);
        mapSelectButton.setFillColor(sf::Color(70, 130, 180));
        mapSelectText.setFont(font);
        mapSelectText.setString(L"Карта 1");
        mapSelectText.setCharacterSize(30 * scaleY);
        mapSelectText.setFillColor(sf::Color::White);
        mapSelectText.setPosition(
            mapSelectButton.getPosition().x + 200 * scaleX - mapSelectText.getGlobalBounds().width/2,
            mapSelectButton.getPosition().y + 30 * scaleY - mapSelectText.getGlobalBounds().height/2
        );
        difficultyTitleText.setFont(font);
        difficultyTitleText.setString(L"Выбор сложности");
        difficultyTitleText.setCharacterSize(48 * scaleY);
        difficultyTitleText.setFillColor(sf::Color::White);
        difficultyTitleText.setPosition(
            centerX - difficultyTitleText.getGlobalBounds().width/2,
            centerY + 20 * scaleY
        );
        difficultySelectButton.setSize(sf::Vector2f(400 * scaleX, 60 * scaleY));
        difficultySelectButton.setPosition(centerX - 200 * scaleX, centerY + 100 * scaleY);
        difficultySelectButton.setFillColor(sf::Color(70, 130, 180));
        difficultySelectText.setFont(font);
        difficultySelectText.setString(L"Легкая");
        difficultySelectText.setCharacterSize(30 * scaleY);
        difficultySelectText.setFillColor(sf::Color::White);
        difficultySelectText.setPosition(
            difficultySelectButton.getPosition().x + 200 * scaleX - difficultySelectText.getGlobalBounds().width/2,
            difficultySelectButton.getPosition().y + 30 * scaleY - difficultySelectText.getGlobalBounds().height/2
        );
        startGameButton.setSize(sf::Vector2f(400 * scaleX, 60 * scaleY));
        startGameButton.setPosition(centerX - 200 * scaleX, centerY + 200 * scaleY);
        startGameButton.setFillColor(sf::Color(70, 180, 70));
        startGameText.setFont(font);
        startGameText.setString(L"Начать игру");
        startGameText.setCharacterSize(30 * scaleY);
        startGameText.setFillColor(sf::Color::White);
        startGameText.setPosition(
            startGameButton.getPosition().x + 200 * scaleX - startGameText.getGlobalBounds().width/2,
            startGameButton.getPosition().y + 30 * scaleY - startGameText.getGlobalBounds().height/2
        );
        mapBackButton.setSize(sf::Vector2f(400 * scaleX, 60 * scaleY));
        mapBackButton.setPosition(centerX - 200 * scaleX, centerY + 300 * scaleY);
        mapBackButton.setFillColor(sf::Color(180, 70, 70));
        mapBackText.setFont(font);
        mapBackText.setString(L"Вернуться в меню");
        mapBackText.setCharacterSize(30 * scaleY);
        mapBackText.setFillColor(sf::Color::White);
        mapBackText.setPosition(
            mapBackButton.getPosition().x + 200 * scaleX - mapBackText.getGlobalBounds().width/2,
            mapBackButton.getPosition().y + 30 * scaleY - mapBackText.getGlobalBounds().height/2
        );

        // --- CHARACTER SELECT ---
        redCubeButton.setSize(sf::Vector2f(200 * scaleX, 200 * scaleY));
        redCubeButton.setFillColor(sf::Color::Red);
        redCubeButton.setPosition(centerX - 350 * scaleX, centerY - 100 * scaleY);
        greenCubeButton.setSize(sf::Vector2f(200 * scaleX, 200 * scaleY));
        greenCubeButton.setFillColor(sf::Color::Green);
        greenCubeButton.setPosition(centerX - 100 * scaleX, centerY - 100 * scaleY);
        blueCubeButton.setSize(sf::Vector2f(200 * scaleX, 200 * scaleY));
        blueCubeButton.setFillColor(sf::Color::Blue);
        blueCubeButton.setPosition(centerX + 150 * scaleX, centerY - 100 * scaleY);
        redCubeText.setFont(font);
        redCubeText.setString(L"Красный");
        redCubeText.setCharacterSize(32 * scaleY);
        redCubeText.setFillColor(sf::Color::White);
        redCubeText.setPosition(redCubeButton.getPosition().x + 60 * scaleX, redCubeButton.getPosition().y + 210 * scaleY);
        greenCubeText.setFont(font);
        greenCubeText.setString(L"Зеленый");
        greenCubeText.setCharacterSize(32 * scaleY);
        greenCubeText.setFillColor(sf::Color::White);
        greenCubeText.setPosition(greenCubeButton.getPosition().x + 50 * scaleX, greenCubeButton.getPosition().y + 210 * scaleY);
        blueCubeText.setFont(font);
        blueCubeText.setString(L"Синий");
        blueCubeText.setCharacterSize(32 * scaleY);
        blueCubeText.setFillColor(sf::Color::White);
        blueCubeText.setPosition(blueCubeButton.getPosition().x + 60 * scaleX, blueCubeButton.getPosition().y + 210 * scaleY);

        // --- Остальные элементы (логин/регистрация/ошибки) ---
        float formY = centerY - fieldHeight - spacingY;
        usernameText.setFont(font);
        usernameText.setString(L"Имя пользователя:");
        usernameText.setCharacterSize(30 * scaleY);
        usernameText.setFillColor(sf::Color::White);
        usernameText.setPosition(centerX - fieldWidth/2 - labelOffsetX - 200 * scaleX, formY);
        usernameBox.setSize(sf::Vector2f(fieldWidth, fieldHeight));
        usernameBox.setPosition(centerX - fieldWidth/2, formY);
        usernameBox.setFillColor(sf::Color::White);
        inputText.setFont(font);
        inputText.setCharacterSize(30 * scaleY);
        inputText.setFillColor(sf::Color::Black);
        inputText.setPosition(usernameBox.getPosition().x + 10 * scaleX, usernameBox.getPosition().y + 8 * scaleY);
        passwordText.setFont(font);
        passwordText.setString(L"Пароль:");
        passwordText.setCharacterSize(30 * scaleY);
        passwordText.setFillColor(sf::Color::White);
        passwordText.setPosition(centerX - fieldWidth/2 - labelOffsetX - 200 * scaleX, formY + fieldHeight + spacingY);
        passwordBox.setSize(sf::Vector2f(fieldWidth, fieldHeight));
        passwordBox.setPosition(centerX - fieldWidth/2, formY + fieldHeight + spacingY);
        passwordBox.setFillColor(sf::Color::White);
        passwordInputText.setFont(font);
        passwordInputText.setCharacterSize(30 * scaleY);
        passwordInputText.setFillColor(sf::Color::Black);
        passwordInputText.setPosition(passwordBox.getPosition().x + 10 * scaleX, passwordBox.getPosition().y + 8 * scaleY);
        float showBtnSize = fieldHeight;
        showPasswordButton.setSize(sf::Vector2f(showBtnSize, showBtnSize));
        showPasswordButton.setPosition(passwordBox.getPosition().x + fieldWidth + 10 * scaleX, passwordBox.getPosition().y);
        showPasswordButton.setFillColor(sf::Color(70, 130, 180));
        showPasswordButton.setOutlineThickness(2);
        showPasswordButton.setOutlineColor(sf::Color::White);
        showPasswordText.setFont(font);
        showPasswordText.setString(isPasswordVisible ? L"1" : L"Х");
        showPasswordText.setCharacterSize(22 * scaleY);
        showPasswordText.setFillColor(sf::Color::White);
        showPasswordText.setPosition(
            showPasswordButton.getPosition().x + showBtnSize/2 - showPasswordText.getGlobalBounds().width/2,
            showPasswordButton.getPosition().y + showBtnSize/2 - showPasswordText.getGlobalBounds().height/1.5f
        );
        submitButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        submitButton.setPosition(centerX - buttonWidth/2, passwordBox.getPosition().y + fieldHeight + spacingY * 2);
        submitButton.setFillColor(sf::Color(70, 130, 180));
        submitButton.setOutlineThickness(3);
        submitButton.setOutlineColor(sf::Color::White);
        submitText.setFont(font);
        submitText.setString(L"Регистрация");
        submitText.setCharacterSize(36 * scaleY);
        submitText.setFillColor(sf::Color::White);
        
        // Центрируем текст кнопки
        submitText.setPosition(
            submitButton.getPosition().x + (buttonWidth - submitText.getGlobalBounds().width) / 2,
            submitButton.getPosition().y + (buttonHeight - submitText.getGlobalBounds().height) / 2
        );
        backButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        backButton.setPosition(centerX - buttonWidth/2, submitButton.getPosition().y + buttonHeight + spacingY);
        backButton.setFillColor(sf::Color(180, 70, 70));
        backButton.setOutlineThickness(3);
        backButton.setOutlineColor(sf::Color::White);
        backText.setFont(font);
        backText.setString(L"Назад");
        backText.setCharacterSize(36 * scaleY);
        backText.setFillColor(sf::Color::White);
        backText.setPosition(
            backButton.getPosition().x + buttonWidth/2 - backText.getGlobalBounds().width/2,
            backButton.getPosition().y + buttonHeight/2 - backText.getGlobalBounds().height/2
        );
        errorText.setFont(font);
        errorText.setCharacterSize(20 * scaleY);
        errorText.setFillColor(sf::Color::Red);
        errorText.setPosition(centerX - buttonWidth/2, backButton.getPosition().y + buttonHeight + spacingY);

        // Initialize Highscores elements
        highscoresBackButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
        highscoresBackButton.setPosition(centerX - buttonWidth/2, screenSize.y - buttonHeight - 20 * scaleY);
        highscoresBackButton.setFillColor(sf::Color(70, 130, 180));
        highscoresBackButton.setOutlineThickness(3);
        highscoresBackButton.setOutlineColor(sf::Color::White);

        highscoresBackText.setFont(font);
        highscoresBackText.setString(L"Назад");
        highscoresBackText.setCharacterSize(36 * scaleY);
        highscoresBackText.setFillColor(sf::Color::White);
        highscoresBackText.setPosition(
            highscoresBackButton.getPosition().x + buttonWidth/2 - highscoresBackText.getGlobalBounds().width/2,
            highscoresBackButton.getPosition().y + buttonHeight/2 - highscoresBackText.getGlobalBounds().height/2
        );

        highscoresTitleText.setFont(font);
        highscoresTitleText.setString(L"Таблица лидеров");
        highscoresTitleText.setCharacterSize(48 * scaleY);
        highscoresTitleText.setFillColor(sf::Color::White);
        highscoresTitleText.setPosition(
            centerX - highscoresTitleText.getGlobalBounds().width/2,
            50 * scaleY
        );

        highscoresTable.setSize(sf::Vector2f(800 * scaleX, 500 * scaleY));
        highscoresTable.setPosition(centerX - 400 * scaleX, 150 * scaleY);
        highscoresTable.setFillColor(sf::Color(0, 0, 0, 200));
        highscoresTable.setOutlineThickness(2);
        highscoresTable.setOutlineColor(sf::Color::White);

        highscoresTableText.setFont(font);
        highscoresTableText.setString(L"Пока нет записей");
        highscoresTableText.setCharacterSize(36 * scaleY);
        highscoresTableText.setFillColor(sf::Color::White);
        highscoresTableText.setPosition(
            centerX - highscoresTableText.getGlobalBounds().width/2,
            400 * scaleY
        );

        // Character select elements
        characterSelectTitle.setFont(font);
        characterSelectTitle.setString(L"Выберите персонажа");
        characterSelectTitle.setCharacterSize(40);
        characterSelectTitle.setFillColor(sf::Color::White);
        characterSelectTitle.setPosition(
            window.getSize().x / 2 - characterSelectTitle.getGlobalBounds().width / 2,
            50
        );
        
        characterBackButton.setSize(sf::Vector2f(200, 50));
        characterBackButton.setPosition(50, window.getSize().y - 70);
        characterBackButton.setFillColor(sf::Color(70, 130, 180));
        
        characterBackText.setFont(font);
        characterBackText.setString(L"Назад");
        characterBackText.setCharacterSize(24);
        characterBackText.setFillColor(sf::Color::White);
        characterBackText.setPosition(
            characterBackButton.getPosition().x + characterBackButton.getSize().x / 2 - characterBackText.getGlobalBounds().width / 2,
            characterBackButton.getPosition().y + characterBackButton.getSize().y / 2 - characterBackText.getGlobalBounds().height / 2
        );
    } catch (const std::exception& e) {
        std::cerr << "Error initializing UI elements: " << e.what() << std::endl;
        throw;
    }
}

void AuthWindow::run() {
    try {
        while (window.isOpen()) {
            handleEvents();
            draw();
        }
    } catch (const exception& e) {
        cerr << "Error in main loop: " << e.what() << endl;
        throw;
    }
}

void AuthWindow::handleEvents() {
    sf::Event event;
    while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed) {
            window.close();
        }
        
        switch (currentState) {
            case WindowState::MAIN:
                handleMainWindowEvents(event);
                break;
            case WindowState::LOGIN:
                handleLoginWindowEvents(event);
                break;
            case WindowState::REGISTER:
                handleRegisterWindowEvents(event);
                break;
            case WindowState::MAIN_MENU:
                handleMainMenuEvents(event);
                break;
            case WindowState::MAP_SELECTION:
                handleMapSelectionEvents(event);
                break;
            case WindowState::CHARACTER_SELECT:
                handleCharacterSelectEvents(event);
                break;
            case WindowState::SETTINGS:
                handleSettingsEvents(event);
                break;
            case WindowState::EXIT_CONFIRMATION:
                handleExitConfirmationEvents(event);
                break;
            case WindowState::HIGHSCORES:
                handleHighscoresEvents(event);
                break;
            case WindowState::PAUSE:
                // Handle pause state if needed
                break;
        }
    }
}

void AuthWindow::handleMainWindowEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (loginButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::LOGIN;
            submitText.setString(L"Вход");
            username = "";
            password = "";
            inputText.setString("");
            passwordInputText.setString("");
            errorText.setString("");
        }
        else if (registerButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::REGISTER;
            submitText.setString(L"Регистрация");
            username = "";
            password = "";
            inputText.setString("");
            passwordInputText.setString("");
            errorText.setString("");
        }
        else if (exitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            window.close();
        }
    }
}

void AuthWindow::handleLoginWindowEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        isUsernameActive = usernameBox.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));
        isPasswordActive = passwordBox.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));
        
        if (submitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            handleSubmit();
        }
        else if (backButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::MAIN;
        }
        else if (showPasswordButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            togglePasswordVisibility();
        }
    }
    
    if (event.type == sf::Event::TextEntered) {
        if (isUsernameActive) {
            if (event.text.unicode == '\b' && !username.empty()) {
                username.pop_back();
            }
            else if (event.text.unicode < 128) {
                username += static_cast<char>(event.text.unicode);
            }
            inputText.setString(username);
            cursor.setPosition(inputText.getPosition().x + inputText.getGlobalBounds().width + 2, 
                             inputText.getPosition().y);
        }
        else if (isPasswordActive) {
            if (event.text.unicode == '\b' && !password.empty()) {
                password.pop_back();
            }
            else if (event.text.unicode < 128) {
                password += static_cast<char>(event.text.unicode);
            }
            passwordInputText.setString(isPasswordVisible ? password : string(password.length(), '*'));
            cursor.setPosition(passwordInputText.getPosition().x + passwordInputText.getGlobalBounds().width + 2,
                             passwordInputText.getPosition().y);
        }
    }
    
    if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Return) {
        handleSubmit();
    }
}

void AuthWindow::handleRegisterWindowEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        isUsernameActive = usernameBox.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));
        isPasswordActive = passwordBox.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));
        
        if (submitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            handleSubmit();
        }
        else if (backButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::MAIN;
        }
        else if (showPasswordButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            togglePasswordVisibility();
        }
    }
    
    if (event.type == sf::Event::TextEntered) {
        if (isUsernameActive) {
            if (event.text.unicode == '\b' && !username.empty()) {
                username.pop_back();
            }
            else if (event.text.unicode < 128) {
                username += static_cast<char>(event.text.unicode);
            }
            inputText.setString(username);
            cursor.setPosition(inputText.getPosition().x + inputText.getGlobalBounds().width + 2, 
                             inputText.getPosition().y);
        }
        else if (isPasswordActive) {
            if (event.text.unicode == '\b' && !password.empty()) {
                password.pop_back();
            }
            else if (event.text.unicode < 128) {
                password += static_cast<char>(event.text.unicode);
            }
            passwordInputText.setString(isPasswordVisible ? password : string(password.length(), '*'));
            cursor.setPosition(passwordInputText.getPosition().x + passwordInputText.getGlobalBounds().width + 2,
                             passwordInputText.getPosition().y);
        }
    }
    
    if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Return) {
        handleSubmit();
    }
}

void AuthWindow::handleMainMenuEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (characterButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::MAP_SELECTION;
        }
        else if (characterSelectButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::CHARACTER_SELECT;
        }
        else if (settingsButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            cout << "Entering settings. Current track: " << currentTrack << ", Volume: " << musicVolume << ", isPlaying: " << isMusicPlaying << endl;
            // Сохраняем текущее состояние музыки перед входом в настройки
            if (currentTrack >= 0 && currentTrack < 4) {
                musicTracks[currentTrack].setVolume(musicVolume);
                // Обновляем текст текущего трека в настройках
                currentTrackText.setString("Track " + std::to_string(currentTrack + 1));
                currentTrackText.setPosition(
                    currentTrackText.getPosition().x + currentTrackText.getGlobalBounds().width/2 - currentTrackText.getGlobalBounds().width/2,
                    currentTrackText.getPosition().y
                );
            }
            currentState = WindowState::SETTINGS;
        }
        else if (recordsButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::HIGHSCORES;
        }
        else if (menuExitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            window.close();
        }
    }
}

void AuthWindow::handleMapSelectionEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (mapSelectButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            selectedMap = (selectedMap % 3) + 1;
            mapSelectText.setString(L"Карта " + std::to_wstring(selectedMap));
            
            mapSelectText.setPosition(
                mapSelectButton.getPosition().x + mapSelectButton.getSize().x/2 - mapSelectText.getGlobalBounds().width/2,
                mapSelectButton.getPosition().y + mapSelectButton.getSize().y/2 - mapSelectText.getGlobalBounds().height/2
            );
        }
        else if (difficultySelectButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            // Переключение между уровнями сложности
            if (difficultySelectText.getString() == L"Легкая") {
                difficultySelectText.setString(L"Средняя");
            } else if (difficultySelectText.getString() == L"Средняя") {
                difficultySelectText.setString(L"Сложная");
            } else {
                difficultySelectText.setString(L"Легкая");
            }
            
            // Центрирование текста после изменения
            difficultySelectText.setPosition(
                difficultySelectButton.getPosition().x + difficultySelectButton.getSize().x/2 - difficultySelectText.getGlobalBounds().width/2,
                difficultySelectButton.getPosition().y + difficultySelectButton.getSize().y/2 - difficultySelectText.getGlobalBounds().height/2
            );
        }
        else if (startGameButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            // Определяем выбранную сложность
            Difficulty selectedDifficulty = Difficulty::EASY; // По умолчанию
            if (difficultySelectText.getString() == L"Средняя") {
                selectedDifficulty = Difficulty::MEDIUM;
            } else if (difficultySelectText.getString() == L"Сложная") {
                selectedDifficulty = Difficulty::HARD;
            }

            // Создание и запуск игры с выбранной сложностью
            window.close();
            Game game(selectedDifficulty, selectedMap, username, selectedCharacter);
            game.run();
        }
        else if (mapBackButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            playButtonClickSound();
            currentState = WindowState::MAIN_MENU;
        }
    }
}

void AuthWindow::handleCharacterSelectEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseMoved) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        // Check hover states for each character
        isMikeHovered = mikeSprite.getGlobalBounds().contains(mousePos.x, mousePos.y);
        isJesyHovered = jesySprite.getGlobalBounds().contains(mousePos.x, mousePos.y);
        isGremHovered = gremSprite.getGlobalBounds().contains(mousePos.x, mousePos.y);
        
        // Update sprite scale based on hover
        float normalScale = 0.8f;
        float hoverScale = 1.0f;
        
        if (isMikeHovered) {
            mikeSprite.setScale(hoverScale, hoverScale);
        } else if (selectedCharacter != 0) {
            mikeSprite.setScale(normalScale, normalScale);
        }
        
        if (isJesyHovered) {
            jesySprite.setScale(hoverScale, hoverScale);
        } else if (selectedCharacter != 1) {
            jesySprite.setScale(normalScale, normalScale);
        }
        
        if (isGremHovered) {
            gremSprite.setScale(hoverScale, hoverScale);
        } else if (selectedCharacter != 2) {
            gremSprite.setScale(normalScale, normalScale);
        }
    }
    else if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        // Reset all characters to normal scale first
        float normalScale = 0.8f;
        mikeSprite.setScale(normalScale, normalScale);
        jesySprite.setScale(normalScale, normalScale);
        gremSprite.setScale(normalScale, normalScale);
        
        // Check if any character is clicked
        if (mikeSprite.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            playButtonClickSound();
            selectedCharacter = 0;
            mikeSprite.setScale(1.0f, 1.0f); // Keep enlarged for selected character
        }
        else if (jesySprite.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            playButtonClickSound();
            selectedCharacter = 1;
            jesySprite.setScale(1.0f, 1.0f);
        }
        else if (gremSprite.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            playButtonClickSound();
            selectedCharacter = 2;
            gremSprite.setScale(1.0f, 1.0f);
        }
        else if (characterBackButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            playButtonClickSound();
            currentState = WindowState::MAIN_MENU;
        }
    }
}

void AuthWindow::handleSettingsEvents(const sf::Event& event) {
    sf::Vector2i mousePos = sf::Mouse::getPosition(window);
    float sliderWidth = musicSlider.getSize().x;
    float handleSize = musicSliderHandle.getSize().x;

    if (event.type == sf::Event::MouseButtonPressed) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            // Check if clicking on slider handles
            if (musicSliderHandle.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                isDraggingMusicSlider = true;
            }
            else if (effectsSliderHandle.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                isDraggingEffectsSlider = true;
            }
            // Check other buttons
            else if (prevTrackButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                playButtonClickSound();
                if (currentTrack >= 0 && currentTrack < 4) {
                    musicTracks[currentTrack].stop();
                }
                currentTrack = (currentTrack - 1 + 4) % 4;
                currentTrackText.setString(L"Трек " + std::to_wstring(currentTrack + 1));
                currentTrackText.setPosition(
                    currentTrackText.getPosition().x + currentTrackText.getGlobalBounds().width/2 - currentTrackText.getGlobalBounds().width/2,
                    currentTrackText.getPosition().y
                );
                if (currentTrack >= 0 && currentTrack < 4) {
                    musicTracks[currentTrack].setVolume(musicVolume);
                    musicTracks[currentTrack].play();
                    isMusicPlaying = true;
                }
            }
            else if (nextTrackButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                playButtonClickSound();
                if (currentTrack >= 0 && currentTrack < 4) {
                    musicTracks[currentTrack].stop();
                }
                currentTrack = (currentTrack + 1) % 4;
                currentTrackText.setString(L"Трек " + std::to_wstring(currentTrack + 1));
                currentTrackText.setPosition(
                    currentTrackText.getPosition().x + currentTrackText.getGlobalBounds().width/2 - currentTrackText.getGlobalBounds().width/2,
                    currentTrackText.getPosition().y
                );
                if (currentTrack >= 0 && currentTrack < 4) {
                    musicTracks[currentTrack].setVolume(musicVolume);
                    musicTracks[currentTrack].play();
                    isMusicPlaying = true;
                }
            }
            else if (themeColorButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                playButtonClickSound();
                // Toggle theme
                isDarkTheme = !isDarkTheme;
                if (isDarkTheme) {
                    background.setTexture(&backgroundTexture);
                    themeColorText.setString(L"Тёмная");
                } else {
                    background.setTexture(&lightBackgroundTexture);
                    themeColorText.setString(L"Светлая");
                }
                // Update text position after changing string
                themeColorText.setPosition(
                    themeColorButton.getPosition().x + themeColorButton.getSize().x/2 - themeColorText.getGlobalBounds().width/2,
                    themeColorButton.getPosition().y + themeColorButton.getSize().y/2 - themeColorText.getGlobalBounds().height/2
                );
            }
            else if (settingsBackButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                playButtonClickSound();
                cout << "Returning to menu. Current track: " << currentTrack << ", Volume: " << musicVolume << ", isPlaying: " << isMusicPlaying << endl;
                // Сохраняем текущее состояние перед возвратом в меню
                if (currentTrack >= 0 && currentTrack < 4) {
                    musicTracks[currentTrack].setVolume(musicVolume);
                }
                currentState = WindowState::MAIN_MENU;
            }
        }
    }
    else if (event.type == sf::Event::MouseButtonReleased) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            isDraggingMusicSlider = false;
            isDraggingEffectsSlider = false;
        }
    }
    else if (event.type == sf::Event::MouseMoved) {
        if (isDraggingMusicSlider) {
            float newX = std::max(musicSlider.getPosition().x,
                                std::min(musicSlider.getPosition().x + sliderWidth - handleSize,
                                        static_cast<float>(mousePos.x) - handleSize/2));
            musicSliderHandle.setPosition(newX, musicSliderHandle.getPosition().y);
            musicVolume = ((newX - musicSlider.getPosition().x) / (sliderWidth - handleSize)) * 100.0f;

            // Update volume of current music track only
            if (currentTrack >= 0 && currentTrack < 4) {
                musicTracks[currentTrack].setVolume(musicVolume);
            }
        }
        else if (isDraggingEffectsSlider) {
            float newX = std::max(effectsSlider.getPosition().x,
                                std::min(effectsSlider.getPosition().x + sliderWidth - handleSize,
                                        static_cast<float>(mousePos.x) - handleSize/2));
            effectsSliderHandle.setPosition(newX, effectsSliderHandle.getPosition().y);
            effectsVolume = ((newX - effectsSlider.getPosition().x) / (sliderWidth - handleSize)) * 100.0f;
        }
    }
}

void AuthWindow::handleSubmit() {
    try {
        std::cout << "HandleSubmit called with state: " << 
            (currentState == WindowState::LOGIN ? "LOGIN" : 
             currentState == WindowState::REGISTER ? "REGISTER" : "OTHER") << std::endl;
        
        std::cout << "Username: " << username << ", Password length: " << password.length() << std::endl;
        
        if (currentState == WindowState::LOGIN) {
            if (User::loginUser(username, password)) {
                std::cout << "Login successful, changing to MAIN_MENU" << std::endl;
                enterMainMenu();
                errorText.setString(L"");
            } else {
                std::cout << "Login failed" << std::endl;
                errorText.setString(L"Неверное имя\nпользователя\nили пароль");
            }
        } else if (currentState == WindowState::REGISTER) {
            if (User::registerUser(username, password)) {
                std::cout << "Registration successful, changing to MAIN_MENU" << std::endl;
                enterMainMenu();
                errorText.setString(L"");
            } else {
                std::cout << "Registration failed" << std::endl;
                errorText.setString(L"Ошибка регистрации.\nИмя пользователя\nуже существует.");
            }
        }
    } catch (const exception& e) {
        cerr << "Error during submit: " << e.what() << endl;
        errorText.setString("Произошла ошибка: " + string(e.what()));
    }
}

void AuthWindow::togglePasswordVisibility() {
    isPasswordVisible = !isPasswordVisible;
    passwordInputText.setString(isPasswordVisible ? password : string(password.length(), '*'));
}

void AuthWindow::enterMainMenu() {
    currentState = WindowState::MAIN_MENU;
    // Восстанавливаем состояние музыки
    if (currentTrack >= 0 && currentTrack < 4) {
        // Останавливаем все треки кроме текущего
        for (int i = 0; i < 4; ++i) {
            if (i != currentTrack) {
                musicTracks[i].stop();
            }
        }
        // Устанавливаем громкость и запускаем текущий трек только если он не играет
        musicTracks[currentTrack].setVolume(musicVolume);
        if (!isMusicPlaying) {
            musicTracks[currentTrack].play();
            isMusicPlaying = true;
        }
    }
}

void AuthWindow::handleExitConfirmationEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (confirmExitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            window.close();
        }
        else if (cancelExitButton.getGlobalBounds().contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
            currentState = WindowState::MAIN_MENU;
        }
    }
}

void AuthWindow::handleHighscoresEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            sf::Vector2i mousePos = sf::Mouse::getPosition(window);
            
            if (highscoresBackButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                playButtonClickSound();
                currentState = WindowState::MAIN_MENU;
            }
        }
    }
}

void AuthWindow::draw() {
    window.clear();
    window.draw(background);
    
    switch (currentState) {
        case WindowState::MAIN:
            drawMainWindow();
            break;
        case WindowState::LOGIN:
            drawLoginWindow();
            break;
        case WindowState::REGISTER:
            drawRegisterWindow();
            break;
        case WindowState::MAIN_MENU:
            drawMainMenu();
            break;
        case WindowState::MAP_SELECTION:
            drawMapSelection();
            break;
        case WindowState::CHARACTER_SELECT:
            drawCharacterSelect();
            break;
        case WindowState::SETTINGS:
            drawSettings();
            break;
        case WindowState::EXIT_CONFIRMATION:
            drawExitConfirmation();
            break;
        case WindowState::HIGHSCORES:
            drawHighscores();
            break;
        case WindowState::PAUSE:
            // Draw pause state if needed
            break;
    }
    
    window.display();
}

void AuthWindow::drawMainWindow() {
    window.draw(loginButton);
    window.draw(loginText);
    window.draw(registerButton);
    window.draw(registerText);
    window.draw(exitButton);
    window.draw(exitText);
}

void AuthWindow::drawLoginWindow() {
    window.draw(usernameBox);
    window.draw(passwordBox);
    window.draw(submitButton);
    window.draw(backButton);
    window.draw(showPasswordButton);
    window.draw(usernameText);
    window.draw(passwordText);
    window.draw(submitText);
    window.draw(backText);
    window.draw(showPasswordText);
    window.draw(inputText);
    window.draw(passwordInputText);
    window.draw(errorText);
    
    if ((isUsernameActive || isPasswordActive) && showCursor) {
        window.draw(cursor);
    }
}

void AuthWindow::drawRegisterWindow() {
    window.draw(usernameBox);
    window.draw(passwordBox);
    window.draw(submitButton);
    window.draw(backButton);
    window.draw(showPasswordButton);
    window.draw(usernameText);
    window.draw(passwordText);
    window.draw(submitText);
    window.draw(backText);
    window.draw(showPasswordText);
    window.draw(inputText);
    window.draw(passwordInputText);
    window.draw(errorText);
    
    if ((isUsernameActive || isPasswordActive) && showCursor) {
        window.draw(cursor);
    }
}

void AuthWindow::drawMainMenu() {
    window.draw(characterButton);
    window.draw(characterText);
    window.draw(characterSelectButton);
    window.draw(characterSelectText);
    window.draw(settingsButton);
    window.draw(settingsText);
    window.draw(recordsButton);
    window.draw(recordsText);
    window.draw(menuExitButton);
    window.draw(menuExitText);
}

void AuthWindow::drawMapSelection() {
    window.draw(mapTitleText);
    window.draw(mapSelectButton);
    window.draw(mapSelectText);
    window.draw(difficultyTitleText);
    window.draw(difficultySelectButton);
    window.draw(difficultySelectText);
    window.draw(startGameButton);
    window.draw(startGameText);
    window.draw(mapBackButton);
    window.draw(mapBackText);
}

void AuthWindow::drawCharacterSelect() {
    // Draw background
    window.draw(background);
    
    // Draw title
    window.draw(characterSelectTitle);
    
    // Draw character sprites
    float centerX = window.getSize().x / 2.f;
    float windowWidth = window.getSize().x;
    float centerY = window.getSize().y / 2.f;

    // Calculate positions to place characters more distinctly: left, center, right
    float leftX = windowWidth * 0.25f;  // 25% от ширины экрана
    float middleX = centerX;            // Центр экрана
    float rightX = windowWidth * 0.75f; // 75% от ширины экрана

    // Fixed Y-coordinates for the center of sprites and texts
    float spriteCenterY = centerY - 120; // Y-координата для центров спрайтов
    float textCenterY = centerY + 70;   // Y-координата для центров текста

    // Position sprites (their centers are placed at these coordinates)
    mikeSprite.setPosition(leftX, spriteCenterY);
    jesySprite.setPosition(middleX, spriteCenterY);
    gremSprite.setPosition(rightX, spriteCenterY);
    
    // Position names (using their already set origins, so position is their center)
    mikeText.setPosition(leftX, textCenterY);
    jesyText.setPosition(middleX, textCenterY);
    gremText.setPosition(rightX, textCenterY);
    
    // Draw sprites
    window.draw(mikeSprite);
    window.draw(jesySprite);
    window.draw(gremSprite);
    
    // Draw character names
    window.draw(mikeText);
    window.draw(jesyText);
    window.draw(gremText);
    
    // Draw back button
    window.draw(characterBackButton);
    window.draw(characterBackText);
}

void AuthWindow::drawSettings() {
    window.draw(settingsTitleText);
    window.draw(musicVolumeText);
    window.draw(musicSlider);
    window.draw(musicSliderHandle);
    window.draw(effectsVolumeText);
    window.draw(effectsSlider);
    window.draw(effectsSliderHandle);
    window.draw(prevTrackButton);
    window.draw(nextTrackButton);
    window.draw(currentTrackText);
    window.draw(themeColorButton);
    window.draw(themeColorText);
    window.draw(settingsBackButton);
    window.draw(settingsBackText);
}

void AuthWindow::drawExitConfirmation() {
    window.draw(confirmExitButton);
    window.draw(confirmExitText);
    window.draw(cancelExitButton);
    window.draw(cancelExitText);
    window.draw(exitConfirmationText);
}

void AuthWindow::drawHighscores() {
    window.draw(highscoresTitleText);
    window.draw(highscoresTable);
    window.draw(highscoresBackButton);
    window.draw(highscoresBackText);

    // Получаем записи из таблицы рекордов
    auto records = Records::getInstance().getRecords();
    
    if (records.empty()) {
        window.draw(highscoresTableText);
    } else {
        // Отображаем записи
        float startY = highscoresTable.getPosition().y + 20;
        float rowHeight = 40;
        int index = 0;
        
        for (const auto& record : records) {
            sf::Text recordText;
            recordText.setFont(font);
            recordText.setCharacterSize(24);
            recordText.setFillColor(sf::Color::White);
            
            // Форматируем время в минуты и секунды
            int minutes = record.score / 60;
            int seconds = record.score % 60;
            std::string timeStr = std::to_string(minutes) + ":" + 
                                (seconds < 10 ? "0" : "") + std::to_string(seconds);
            
            // Форматируем строку записи
            std::string recordStr = std::to_string(index + 1) + ". " + 
                                  record.username + " - " + 
                                  timeStr + " (" + 
                                  record.difficulty + ", Map " + 
                                  std::to_string(record.mapNumber) + ")";
            
            recordText.setString(recordStr);
            recordText.setPosition(
                highscoresTable.getPosition().x + 20,
                startY + index * rowHeight
            );
            
            window.draw(recordText);
            index++;
        }
    }
}

void AuthWindow::setState(WindowState state) {
    if (state == WindowState::CHARACTER_SELECT) {
        // Reset character selection highlight when entering this state
        selectedCharacter = -1; // No character selected initially
        // Also reset all character scales to normal when entering this state
        float normalScale = 0.8f;
        mikeSprite.setScale(normalScale, normalScale);
        jesySprite.setScale(normalScale, normalScale);
        gremSprite.setScale(normalScale, normalScale);
    }
    currentState = state;
}

void AuthWindow::playButtonClickSound() {
    buttonClickSound.setVolume(effectsVolume);
    buttonClickSound.play();
}

void AuthWindow::playKeyCollectSound() {
    keyCollectSound.setVolume(effectsVolume);
    keyCollectSound.play();
}

#include "Enemy.hpp"
#include <iostream>

Enemy::Enemy(const sf::Color& color) : 
    velocity(0, 0), speed(2.0f), health(100), maxHealth(100), chaseRange(200.0f) {
    
    shape.setSize(sf::Vector2f(30, 30));
    shape.setFillColor(color);
    shape.setOrigin(15, 15);
}

void Enemy::update(const sf::Vector2f& playerPosition) {
    // Calculate direction to player
    sf::Vector2f direction = playerPosition - shape.getPosition();
    float distance = std::sqrt(direction.x * direction.x + direction.y * direction.y);
    
    // Normalize direction
    if (distance > 0) {
        direction /= distance;
    }
    
    // Move towards player if in range
    if (distance < chaseRange) {
        velocity = direction * speed;
    } else {
        velocity = sf::Vector2f(0, 0);
    }
    
    // Update position
    shape.move(velocity);
    
    // Check wall collisions
    checkWallCollisions();
}

void Enemy::draw(sf::RenderWindow& window) {
    window.draw(shape);
}

void Enemy::takeDamage(int damage) {
    health -= damage;
    if (health < 0) health = 0;
}

void Enemy::setPosition(float x, float y) {
    shape.setPosition(x, y);
}

sf::Vector2f Enemy::getPosition() const {
    return shape.getPosition();
}

sf::FloatRect Enemy::getGlobalBounds() const {
    return shape.getGlobalBounds();
}

int Enemy::getHealth() const {
    return health;
}

void Enemy::checkWallCollisions() {
    sf::FloatRect bounds = shape.getGlobalBounds();
    
    // Check screen boundaries
    if (bounds.left < 0) {
        shape.setPosition(bounds.width / 2, shape.getPosition().y);
        velocity.x = 0;
    }
    else if (bounds.left + bounds.width > 1280) {
        shape.setPosition(1280 - bounds.width / 2, shape.getPosition().y);
        velocity.x = 0;
    }
    
    if (bounds.top < 0) {
        shape.setPosition(shape.getPosition().x, bounds.height / 2);
        velocity.y = 0;
    }
    else if (bounds.top + bounds.height > 800) {
        shape.setPosition(shape.getPosition().x, 800 - bounds.height / 2);
        velocity.y = 0;
    }
}

#include "Game.hpp"
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string> // Добавим для std::to_string
#include "Key.hpp"
#include "Trap.hpp"
#include "Records.hpp"
#include "AuthWindow.hpp"

// Удаляем статические константы размера лабиринта
// static constexpr int MAZE_WIDTH = 15;
// static constexpr int MAZE_HEIGHT = 15;
static constexpr int CELL_SIZE = 32;

namespace {
    // Helper function to load texture with chroma key
    bool loadTextureWithChromaKey(sf::Texture& texture, const std::string& filename, sf::Color chromaKey) {
        sf::Image image;
        if (!image.loadFromFile(filename)) {
            std::cerr << "Failed to load image for chroma key: " << filename << std::endl;
            return false;
        }
        // Define the chroma key color (green)
        image.createMaskFromColor(chromaKey);
        texture.loadFromImage(image);
        return true;
    }
}

Game::Game(Difficulty difficulty, int mapNumber, const std::string& username, int selectedCharacter)
    : window(sf::VideoMode::getDesktopMode(), "Maze Game", sf::Style::Fullscreen),
      player(sf::Vector2f(30.f, 30.f)),
      gameDifficulty(difficulty),
      currentMap(mapNumber),
      username(username),
      isPaused(false),
      isDraggingMusicSlider(false),
      isDraggingEffectsSlider(false),
      musicVolume(50.0f),
      effectsVolume(50.0f),
      playerVelocity(0.f, 0.f),
      playerSpeed(8.0f),
      initialSelectedCharacter(selectedCharacter) {
    window.setFramerateLimit(60);
    
    // Load sound effects
    if (!keyBuffer.loadFromFile("/Users/misa/Desktop/курсовая основа/sounds effects/sborKlucha.ogg")) {
        std::cerr << "Failed to load key sound" << std::endl;
    }
    if (!doorBuffer.loadFromFile("/Users/misa/Desktop/курсовая основа/sounds effects/door.wav")) {
        std::cerr << "Failed to load door sound" << std::endl;
    }
    if (!finishBuffer.loadFromFile("sounds/finish.wav")) {
        std::cerr << "Failed to load finish sound" << std::endl;
    }
    if (!damageBuffer.loadFromFile("/Users/misa/Desktop/курсовая основа/sounds effects/die.ogg")) {
        std::cerr << "Failed to load damage sound" << std::endl;
    }
    
    keySound.setBuffer(keyBuffer);
    doorSound.setBuffer(doorBuffer);
    finishSound.setBuffer(finishBuffer);
    damageSound.setBuffer(damageBuffer);
    
    // Load background music
    if (!backgroundMusic.openFromFile("sounds/background.ogg")) {
        std::cerr << "Failed to load background music" << std::endl;
    }
    backgroundMusic.setLoop(true);
    backgroundMusic.play();
    
    // Set initial volumes
    backgroundMusic.setVolume(musicVolume);
    keySound.setVolume(effectsVolume);
    doorSound.setVolume(effectsVolume);
    finishSound.setVolume(effectsVolume);
    damageSound.setVolume(effectsVolume);
    
    // Устанавливаем размеры лабиринта в зависимости от сложности
    switch (difficulty) {
        case Difficulty::EASY:
            MAZE_WIDTH = 30;
            MAZE_HEIGHT = 30;
            break;
        case Difficulty::MEDIUM:
            MAZE_WIDTH = 45;
            MAZE_HEIGHT = 45;
            break;
        case Difficulty::HARD:
            MAZE_WIDTH = 60;
            MAZE_HEIGHT = 60;
            break;
    }

    // Initialize game state
    playerHealth = 100;
    invincibilityTime = 0;
    isInvincible = false;
    collectedKeys = 0;
    doorOpen = false;
    
    // Initialize damage flash
    damageFlash.setFillColor(sf::Color(255, 0, 0, 128)); // Semi-transparent red
    damageFlashTime = 0;
    isFlashing = false;
    
    // Load font
    if (!font.loadFromFile("/System/Library/Fonts/Supplemental/Arial.ttf")) {
        std::cerr << "Failed to load font" << std::endl;
    }
    
    // Load floor texture based on map number
    std::string floorTexturePath;
    switch (currentMap) {
        case 1:
            floorTexturePath = "/Users/misa/Desktop/курсовая основа/texture/floor/floorLVL1.png";
            break;
        case 2:
            floorTexturePath = "/Users/misa/Desktop/курсовая основа/texture/floor/floorLVL2.png";
            break;
        case 3:
            floorTexturePath = "/Users/misa/Desktop/курсовая основа/texture/floor/floorLVL3.png";
            break;
    }

    if (!floorTexture.loadFromFile(floorTexturePath)) {
        std::cerr << "Failed to load floor texture from " << floorTexturePath << std::endl;
    } else {
        std::cout << "Successfully loaded floor texture from " << floorTexturePath << std::endl;
        floorTexture.setRepeated(true);
    }
    
    // Load wall texture based on map number
    std::string wallTexturePath;
    switch (currentMap) {
        case 1:
            wallTexturePath = "/Users/misa/Desktop/курсовая основа/texture/wall/wallLVL1.jpg";
            break;
        case 2:
            wallTexturePath = "/Users/misa/Desktop/курсовая основа/texture/wall/wallLVL2.png";
            break;
        case 3:
            wallTexturePath = "/Users/misa/Desktop/курсовая основа/texture/wall/wallLVL3.png";
            break;
    }
    
    if (!wallTexture.loadFromFile(wallTexturePath)) {
        std::cerr << "Failed to load wall texture from " << wallTexturePath << std::endl;
    } else {
        std::cout << "Successfully loaded wall texture from " << wallTexturePath << std::endl;
        wallTexture.setRepeated(true);
    }
    
    // Load door textures
    if (!closedDoorTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/door/clotheDoor.png")) {
        std::cerr << "Failed to load closed door texture" << std::endl;
    }
    if (!openDoorTexture.loadFromFile("/Users/misa/Desktop/курсовая основа/texture/door/openDoor.png")) {
        std::cerr << "Failed to load open door texture" << std::endl;
    }
    
    // Initialize door sprite
    doorSprite.setTexture(closedDoorTexture);
    // Position the door in the center of the maze
    float doorX = (MAZE_WIDTH / 2) * CELL_SIZE;
    float doorY = (MAZE_HEIGHT / 2) * CELL_SIZE;
    doorSprite.setPosition(doorX, doorY);
    
    // Scale the door to be larger than cell size
    float doorScale = static_cast<float>(CELL_SIZE * 2.25f) / closedDoorTexture.getSize().x; // Увеличили в 1.5 раза
    doorSprite.setScale(doorScale, doorScale);
    
    // Set the origin to center of the sprite
    doorSprite.setOrigin(closedDoorTexture.getSize().x / 2.0f, closedDoorTexture.getSize().y / 2.0f);
    
    // Load key texture with chroma key (green)
    if (!loadTextureWithChromaKey(keyTexture, "/Users/misa/Desktop/курсовая основа/texture/key/keyem.png", sf::Color(0, 255, 0))) {
        std::cerr << "Failed to load key texture with chroma key" << std::endl;
    }
    
    // Load trap texture with chroma key (black)
    if (!loadTextureWithChromaKey(trapTexture, "/Users/misa/Desktop/курсовая основа/texture/enemy/lovushka.png", sf::Color::Black)) {
        std::cerr << "Failed to load trap texture with chroma key" << std::endl;
    }
    
    // Initialize health bar
    healthBarBackground.setSize(sf::Vector2f(200, 20));
    healthBarBackground.setFillColor(sf::Color(50, 50, 50));
    healthBarBackground.setPosition(20, 20);
    
    healthBar.setSize(sf::Vector2f(200, 20));
    healthBar.setFillColor(sf::Color::Red);
    healthBar.setPosition(20, 20);
    
    healthText.setFont(font);
    healthText.setCharacterSize(20);
    healthText.setFillColor(sf::Color::White);
    healthText.setPosition(230, 20);
    
    // Initialize timer text
    timerText.setFont(font);
    timerText.setCharacterSize(20);
    timerText.setFillColor(sf::Color::White);
    timerText.setPosition(450, 20);
    
    loadMaze();
    placeTraps();
    placeKeys();
    
    // Player setup
    float playerSizeMultiplier = 0.5f; // Единый множитель для размера игрока. Увеличено для более стабильной работы хитбокса. Регулируйте это значение для изменения размера.
    
    float playerHitboxDimension = CELL_SIZE * playerSizeMultiplier;
    player.setSize(sf::Vector2f(playerHitboxDimension, playerHitboxDimension));
    player.setFillColor(sf::Color::Transparent); // Делаем хитбокс невидимым
    player.setOrigin(playerHitboxDimension / 2, playerHitboxDimension / 2); // Центр хитбокса
    player.setPosition(CELL_SIZE + CELL_SIZE/2, CELL_SIZE + CELL_SIZE/2); // Начальная позиция хитбокса

    // Load player texture based on selectedCharacter
    std::string playerTexturePath;
    // sf::Color chromaKeyColor = sf::Color::Black; // Удалено использование chromaKeyColor

    switch (selectedCharacter) {
        case 0: // Mike (Медведь)
            playerTexturePath = "/Users/misa/Desktop/курсовая основа/texture/cheracter/bear.png";
            break;
        case 1: // Jesy (Динозавр)
            playerTexturePath = "/Users/misa/Desktop/курсовая основа/texture/cheracter/dino.png";
            break;
        case 2: // Grem (Кот)
            playerTexturePath = "/Users/misa/Desktop/курсовая основа/texture/cheracter/cat.png";
            break;
        default:
            // Default texture if something goes wrong or no selection
            playerTexturePath = "/Users/misa/Desktop/курсовая основа/texture/cheracter/bear.png";
            break;
    }

    if (!playerTexture.loadFromFile(playerTexturePath)) { // Прямая загрузка файла без chroma key
        std::cerr << "Failed to load player texture from " << playerTexturePath << std::endl;
    } else {
        std::cout << "Successfully loaded player texture from " << playerTexturePath << std::endl;
        playerSprite.setTexture(playerTexture); // Применяем загруженную текстуру к спрайту
        
        // Масштабируем текстуру относительно ее оригинального размера, чтобы она соответствовала hitboxDimension
        // и затем применяем visualAdjustmentFactor для визуального увеличения
        float textureScaleX = playerHitboxDimension / playerTexture.getSize().x;
        float textureScaleY = playerHitboxDimension / playerTexture.getSize().y;
        
        float visualAdjustmentFactor = 1.2f; // Коэффициент для визуального увеличения текстуры по сравнению с хитбоксом
        playerSprite.setScale(textureScaleX * visualAdjustmentFactor, textureScaleY * visualAdjustmentFactor);
        
        playerSprite.setOrigin(playerTexture.getSize().x / 2.0f, playerTexture.getSize().y / 2.0f); // Центр спрайта
        playerSprite.setPosition(player.getPosition()); // Располагаем спрайт по позиции хитбокса
    }
    
    // Finish setup
    float finishSize = CELL_SIZE / 2.0f; // Match player size
    finish.setSize(sf::Vector2f(finishSize, finishSize));
    finish.setFillColor(sf::Color::Yellow);
    finish.setOrigin(finishSize / 2, finishSize / 2); // Set origin to center
    // Position the finish in the center of the maze
    finish.setPosition((MAZE_WIDTH / 2) * CELL_SIZE + CELL_SIZE/2, (MAZE_HEIGHT / 2) * CELL_SIZE + CELL_SIZE/2);
    
    // Camera setup
    camera.setSize(window.getSize().x, window.getSize().y);
    camera.setCenter(player.getPosition());
    
    // Set initial camera bounds
    float minX = camera.getSize().x / 2;
    float minY = camera.getSize().y / 2;
    float maxX = MAZE_WIDTH * CELL_SIZE - camera.getSize().x / 2;
    float maxY = MAZE_HEIGHT * CELL_SIZE - camera.getSize().y / 2;
    camera.setCenter(sf::Vector2f(
        std::max(minX, std::min(player.getPosition().x, maxX)),
        std::max(minY, std::min(player.getPosition().y, maxY))
    ));

    initializePauseMenu();
    initializeGameOverWindow();
    showGameOver = false;
}

void Game::placeTraps() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::vector<std::pair<int, int>> potentialTrapPositions;
    
    // Determine trap damage based on difficulty
    int trapDamage = 0;
    switch (gameDifficulty) {
        case Difficulty::EASY:
            trapDamage = 5;
            break;
        case Difficulty::MEDIUM:
            trapDamage = 10;
            break;
        case Difficulty::HARD:
            trapDamage = 20;
            break;
    }

    // Collect potential trap positions that are path cells with a wall directly above them
    for (int y = 1; y < MAZE_HEIGHT - 1; ++y) { // Start from y=1 to check for wall at y-1
        for (int x = 1; x < MAZE_WIDTH - 1; ++x) {
            if (maze[y][x] == 0 && maze[y-1][x] == 1) { // If it's a path cell AND there's a wall directly above
                 potentialTrapPositions.push_back({x, y});
            }
        }
    }
    
    // Shuffle the potential positions and select 15
    std::shuffle(potentialTrapPositions.begin(), potentialTrapPositions.end(), gen);
    
    traps.clear(); // Clear existing traps
    for (int i = 0; i < 15 && i < potentialTrapPositions.size(); ++i) { // Limit to 15 traps
        int x = potentialTrapPositions[i].first;
        int y = potentialTrapPositions[i].second;
        
        Trap trap(trapTexture, trapDamage); // Pass the determined damage
        
        // Scale the trap sprite to a fixed size relative to CELL_SIZE
        float targetSize = static_cast<float>(CELL_SIZE) * 0.8f; // Make trap 80% of cell size
        float trapOriginalWidth = trapTexture.getSize().x;
        float trapOriginalHeight = trapTexture.getSize().y;
        float scaleFactor = targetSize / std::max(trapOriginalWidth, trapOriginalHeight);
        trap.sprite.setScale(scaleFactor, scaleFactor);
        
        // Get the scaled dimensions for positioning
        float trapWidth = trap.sprite.getGlobalBounds().width;
        float trapHeight = trap.sprite.getGlobalBounds().height;
        
        // Position the trap sprite horizontally centered in the cell
        float finalTrapX = x * CELL_SIZE + CELL_SIZE / 2;
        // Position the trap sprite vertically so its top edge aligns with the top edge of the cell
        // The center of the sprite will be at y*CELL_SIZE + trapHeight / 2
        float finalTrapY = y * CELL_SIZE + trapHeight / 2;
        
        trap.setPosition(finalTrapX, finalTrapY);
        
        traps.push_back(trap);
    }
}

void Game::placeKeys() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::vector<std::pair<int, int>> potentialKeyPositions;
    
    // Collect positions near the edges of the maze
    for (int y = 1; y < MAZE_HEIGHT - 1; ++y) {
        for (int x = 1; x < MAZE_WIDTH - 1; ++x) {
            if (maze[y][x] == 0) { // If it's a path
                // Check if it's near the edge (within 3 cells)
                if (x <= 3 || x >= MAZE_WIDTH - 4 || y <= 3 || y >= MAZE_HEIGHT - 4) {
                    potentialKeyPositions.push_back({x, y});
                }
            }
        }
    }
    
    // Shuffle and select 3 positions
    std::shuffle(potentialKeyPositions.begin(), potentialKeyPositions.end(), gen);
    
    keys.clear(); // Clear existing keys
    for (int i = 0; i < 3 && i < potentialKeyPositions.size(); ++i) {
        int x = potentialKeyPositions[i].first;
        int y = potentialKeyPositions[i].second;
        
        Key key(keyTexture); // Create Key object with texture
        // Position the key sprite in the center of the cell
        key.setPosition(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2);
        
        // Scale the key sprite to be slightly larger than the player/finish
        // Assuming player/finish size is around CELL_SIZE - 50 (from player initialization)
        // The key sprite's original size is based on the image.
        // We need to scale it relative to its original size.
        float keyOriginalWidth = keyTexture.getSize().x;
        float keyOriginalHeight = keyTexture.getSize().y;
        float targetSize = static_cast<float>(CELL_SIZE) - 30; // Увеличиваем targetSize для увеличения ключа
        float scaleFactor = targetSize / std::max(keyOriginalWidth, keyOriginalHeight);
        key.sprite.setScale(scaleFactor, scaleFactor);
        
        keys.push_back(key);
    }
}

void Game::checkTrapCollisions() {
    if (isInvincible) {
        invincibilityTime -= 1.0f/60.0f; // Assuming 60 FPS
        if (invincibilityTime <= 0) {
            isInvincible = false;
        }
        return;
    }
    
    for (const auto& trap : traps) {
        if (player.getGlobalBounds().intersects(trap.getGlobalBounds())) {
            playerHealth -= trap.getDamage();
            if (playerHealth < 0) playerHealth = 0;
            isInvincible = true;
            invincibilityTime = 1.0f; // 1 second of invincibility
            
            // Start damage flash effect
            isFlashing = true;
            damageFlashTime = 0.5f; // 0.5 seconds flash duration
            
            // Set damage flash size to cover the player
            damageFlash.setSize(player.getSize());
            damageFlash.setPosition(player.getPosition());
            damageFlash.setOrigin(player.getSize().x / 2, player.getSize().y / 2);

            // Воспроизводим звук смерти только когда здоровье достигает 0
            if (playerHealth == 0) {
                damageSound.play();
            }
            break;
        }
    }
}

void Game::checkKeyCollection() {
    for (auto it = keys.begin(); it != keys.end();) {
        if (player.getGlobalBounds().intersects(it->getGlobalBounds())) {
            it->collect(); // Mark key as collected
            collectedKeys++;
            keySound.play(); // Воспроизводим звук сбора ключа
            it = keys.erase(it); // Remove collected key from the list
        } else {
            ++it;
        }
    }
    
    // Update door state
    doorOpen = (collectedKeys == 3);
    if (doorOpen) {
        doorSprite.setTexture(openDoorTexture);
        doorSound.play();
    }
}

void Game::updateDamageFlash() {
    if (isFlashing) {
        damageFlashTime -= 1.0f/60.0f; // Assuming 60 FPS
        
        // Update flash opacity based on remaining time
        float opacity = (damageFlashTime / 0.5f) * 128; // Fade from 128 to 0
        damageFlash.setFillColor(sf::Color(255, 0, 0, static_cast<sf::Uint8>(opacity)));
        
        // Make flash cover the sides of the screen
        damageFlash.setSize(sf::Vector2f(window.getSize().x, window.getSize().y));
        damageFlash.setPosition(0, 0);
        
        if (damageFlashTime <= 0) {
            isFlashing = false;
        }
    }
}

void Game::update() {
    // Update timer
    sf::Time elapsed = gameClock.getElapsedTime();
    
    // Update player sprite position to match hitbox position
    playerSprite.setPosition(player.getPosition());

    // Update door state
    if (collectedKeys == 3 && !doorOpen) {
        doorOpen = true;
        doorSprite.setTexture(openDoorTexture);
        doorSound.play();
    }
    
    if (showGameOver) {
        return;
    }
    
    // Update player input
    handlePlayerInput();
    
    // Update camera
    updateCamera();
    
    // Check for finish
    if (isAtFinish() && doorOpen) {
        showGameOver = true;
        gameOverTitle.setString(L"Вы выиграли!");
        gameOverTitle.setPosition(
            gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTitle.getGlobalBounds().width/2,
            gameOverWindow.getPosition().y + 20
        );
        float finalTime = elapsed.asSeconds();
        int finalMinutes = static_cast<int>(finalTime) / 60;
        int finalSeconds = static_cast<int>(finalTime) % 60;
        gameOverTime.setString(
    L"Время: " + 
    std::to_wstring(finalMinutes) + 
    L":" + 
    (finalSeconds < 10 ? L"0" : L"") + 
    std::to_wstring(finalSeconds)
);
        gameOverTime.setPosition(
            gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTime.getGlobalBounds().width/2,
            gameOverWindow.getPosition().y + 100
        );
        
        // Save the score
        std::string difficultyStr;
        switch (gameDifficulty) {
            case Difficulty::EASY:
                difficultyStr = "Easy";
                break;
            case Difficulty::MEDIUM:
                difficultyStr = "Medium";
                break;
            case Difficulty::HARD:
                difficultyStr = "Hard";
                break;
        }
        Records::getInstance().addRecord(username, static_cast<int>(finalTime), difficultyStr, currentMap);
    }
    
    // Check trap collisions
    checkTrapCollisions();
    
    // Update damage flash
    updateDamageFlash();
    
    // Check key collection
    checkKeyCollection();
    
    // Update health bar
    updateHealthBar();
    
    // Update keys
    for (auto& key : keys) {
        key.update();
    }
    
    // Check for death
    if (playerHealth <= 0) {
        showGameOver = true;
        gameOverTitle.setString(L"Игра окончена!");
        gameOverTitle.setPosition(
            gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTitle.getGlobalBounds().width/2,
            gameOverWindow.getPosition().y + 20
        );
        gameOverTime.setString(L"Вы умерли!");
        gameOverTime.setPosition(
            gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTime.getGlobalBounds().width/2,
            gameOverWindow.getPosition().y + 100
        );
    }
    
    // Update timer text
    int seconds = static_cast<int>(elapsed.asSeconds());
    int minutes = seconds / 60;
    seconds %= 60;
    timerText.setString(std::to_string(minutes) + ":" + (seconds < 10 ? "0" : "") + std::to_string(seconds));
}

void Game::draw() {
    window.clear(sf::Color::Black);
    
    // Set the view for the game world
    window.setView(camera);
    
    // Draw floor tiles
    for (const auto& tile : floorTiles) {
        window.draw(tile);
    }
    
    // Draw walls
    for (const auto& wall : walls) {
        window.draw(wall);
    }
    
    // Draw door (без прозрачности)
    doorSprite.setColor(sf::Color::White); // Устанавливаем полную непрозрачность
    window.draw(doorSprite);
    
    // Draw keys
    for (const auto& key : keys) {
        key.draw(window);
    }
    
    // Draw traps
    for (const auto& trap : traps) {
        trap.draw(window);
    }
    
    // Draw the player sprite
    window.draw(playerSprite);
    
    // Draw finish (only if door is open)
    if (doorOpen) {
        finish.setFillColor(sf::Color::Transparent);
        window.draw(finish);
    }
    
    // Reset view for UI elements
    window.setView(window.getDefaultView());
    
    // Draw health bar
    window.draw(healthBarBackground);
    window.draw(healthBar);
    window.draw(healthText);
    
    // Draw timer
    window.draw(timerText);
    
    // Draw damage flash if active
    if (isFlashing) {
        window.draw(damageFlash);
    }
    
    // Draw pause menu if game is paused
    if (isPaused) {
        drawPauseMenu();
    }
    
    // Draw game over window if game is over
    if (showGameOver) {
        drawGameOverWindow();
    }
    
    window.display();
}

// Вспомогательная функция для генерации лабиринта с помощью DFS
void generateMazeDFS(std::vector<std::vector<int>>& maze, int width, int height, int x, int y, std::mt19937& rng) {
    static const int DX[4] = {0, 0, 1, -1};
    static const int DY[4] = {1, -1, 0, 0};
    std::vector<int> dirs = {0, 1, 2, 3};
    std::shuffle(dirs.begin(), dirs.end(), rng);
    for (int dir : dirs) {
        int nx = x + DX[dir]*2;
        int ny = y + DY[dir]*2;
        if (nx > 0 && nx < width-1 && ny > 0 && ny < height-1 && maze[ny][nx] == 1) {
            maze[y + DY[dir]][x + DX[dir]] = 0; // Убираем стену между
            maze[ny][nx] = 0; // Открываем клетку
            generateMazeDFS(maze, width, height, nx, ny, rng);
        }
    }
}

void Game::loadMaze() {
    // Инициализируем вектор лабиринта с заданными размерами
    maze.assign(MAZE_HEIGHT, std::vector<int>(MAZE_WIDTH, 1));

    // Генерируем лабиринт с помощью DFS
    std::random_device rd;
    std::mt19937 rng(rd());
    maze[1][1] = 0;
    generateMazeDFS(maze, MAZE_WIDTH, MAZE_HEIGHT, 1, 1, rng);
    
    // Гарантируем финиш и область вокруг него
    int centerX = MAZE_WIDTH/2;
    int centerY = MAZE_HEIGHT/2;
    for(int y = centerY-1; y <= centerY+1; y++) {
        for(int x = centerX-1; x <= centerX+1; x++) {
            if(x >= 0 && x < MAZE_WIDTH && y >= 0 && y < MAZE_HEIGHT) {
                maze[y][x] = 0;
            }
        }
    }
    
    // Генерируем стены
    walls.clear();
    floorTiles.clear(); // Clear previous floor tiles
    for (int y = 0; y < MAZE_HEIGHT; ++y) {
        for (int x = 0; x < MAZE_WIDTH; ++x) {
            if (maze[y][x] == 1) {
                sf::RectangleShape wall(sf::Vector2f(CELL_SIZE, CELL_SIZE));
                wall.setPosition(x*CELL_SIZE, y*CELL_SIZE);
                wall.setTexture(&wallTexture); // Применяем текстуру
                wall.setTextureRect(sf::IntRect(0, 0, CELL_SIZE, CELL_SIZE)); // Устанавливаем область текстуры для повторения
                walls.push_back(wall);
            } else { // It's a path, create a floor tile
                sf::Sprite floorTile(floorTexture);
                floorTile.setPosition(x*CELL_SIZE, y*CELL_SIZE);
                floorTile.setScale(static_cast<float>(CELL_SIZE) / floorTexture.getSize().x, static_cast<float>(CELL_SIZE) / floorTexture.getSize().y);
                floorTiles.push_back(floorTile);
            }
        }
    }
    // Reset player size and position
    float playerSize = CELL_SIZE / 2.0f;
    player.setSize(sf::Vector2f(playerSize, playerSize));
    player.setOrigin(playerSize / 2, playerSize / 2);
    player.setPosition(CELL_SIZE + CELL_SIZE/2, CELL_SIZE + CELL_SIZE/2);
    
    // Reset finish size and position
    float finishSize = CELL_SIZE / 2.0f;
    finish.setSize(sf::Vector2f(finishSize, finishSize));
    finish.setOrigin(finishSize / 2, finishSize / 2);
    finish.setPosition((MAZE_WIDTH / 2) * CELL_SIZE + CELL_SIZE/2, (MAZE_HEIGHT / 2) * CELL_SIZE + CELL_SIZE/2);
}

void Game::handlePlayerInput() {
    sf::Vector2f move(0, 0);
    
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W) || sf::Keyboard::isKeyPressed(sf::Keyboard::Up)) move.y -= playerSpeed;
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::S) || sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) move.y += playerSpeed;
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::A) || sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) move.x -= playerSpeed;
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::D) || sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) move.x += playerSpeed;
    
    if (move.x != 0 || move.y != 0) {
        // Normalize diagonal movement
        if (move.x != 0 && move.y != 0) {
            move.x *= 0.7071f; // 1/sqrt(2)
            move.y *= 0.7071f;
        }
        
        // Check collisions separately for X and Y movement
        sf::FloatRect nextPos = player.getGlobalBounds();
        nextPos.left += move.x;
        nextPos.top += move.y;
        
        bool canMoveX = true;
        bool canMoveY = true;
        
        // Test X movement
        if (move.x != 0) {
            sf::FloatRect testX = player.getGlobalBounds();
            testX.left += move.x;
            canMoveX = !checkCollision(testX);
        }
        
        // Test Y movement
        if (move.y != 0) {
            sf::FloatRect testY = player.getGlobalBounds();
            testY.top += move.y;
            canMoveY = !checkCollision(testY);
        }
        
        // Apply movement
        if (canMoveX) player.move(move.x, 0);
        if (canMoveY) player.move(0, move.y);
    }
}

bool Game::checkCollision(const sf::FloatRect& rect) {
    // Check wall collisions
    for (const auto& wall : walls) {
        if (wall.getGlobalBounds().intersects(rect)) return true;
    }
    
    // Check door collision only if door is closed
    if (!doorOpen) {
        // Create a smaller hitbox for the door
        sf::FloatRect doorHitbox = doorSprite.getGlobalBounds();
        float hitboxReduction = doorHitbox.width * 0.35f; // Увеличили хитбокс (было 0.4, стало 0.35)
        doorHitbox.left += hitboxReduction;
        doorHitbox.top += hitboxReduction;
        doorHitbox.width -= hitboxReduction * 2;
        doorHitbox.height -= hitboxReduction * 2;
        
        if (doorHitbox.intersects(rect)) return true;
    }
    
    return false;
}

void Game::updateCamera() {
    sf::Vector2f playerPos = player.getPosition();
    float minX = camera.getSize().x / 2;
    float minY = camera.getSize().y / 2;
    float maxX = MAZE_WIDTH * CELL_SIZE - camera.getSize().x / 2;
    float maxY = MAZE_HEIGHT * CELL_SIZE - camera.getSize().y / 2;
    playerPos.x = std::max(minX, std::min(playerPos.x, maxX));
    playerPos.y = std::max(minY, std::min(playerPos.y, maxY));
    sf::Vector2f currentCenter = camera.getCenter();
    sf::Vector2f newCenter = currentCenter + (playerPos - currentCenter) * 0.1f;
    camera.setCenter(newCenter);
}

bool Game::isAtFinish() const {
    // Проверяем пересечение с финишем И состояние двери
    return player.getGlobalBounds().intersects(finish.getGlobalBounds()) && doorOpen;
}

bool Game::canOpenDoor() const {
    return doorOpen;
}

void Game::updateHealthBar() {
    float healthPercentage = static_cast<float>(playerHealth) / 100.0f;
    healthBar.setSize(sf::Vector2f(200 * healthPercentage, 20));
    healthText.setString(std::to_string(playerHealth));
}

void Game::run() {
    while (window.isOpen()) {
        processEvents();
        
        if (!isPaused) {
            update();
        }
        
        draw();
    }
}

void Game::processEvents() {
    sf::Event event;
    while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed) {
            window.close();
        }
        if (event.type == sf::Event::Resized) {
            sf::FloatRect visibleArea(0, 0, event.size.width, event.size.height);
            window.setView(sf::View(visibleArea));
            camera.setSize(event.size.width, event.size.height);
        }
        
        if (showGameOver) {
            handleGameOverEvents(event);
            continue;
        }
        
        if (event.type == sf::Event::KeyPressed) {
            if (event.key.code == sf::Keyboard::Escape) {
                togglePause();
            }
        }
        
        if (isPaused) {
            handlePauseEvents(event);
        } else {
            // Обработка движения игрока
            if (event.type == sf::Event::KeyPressed) {
                switch (event.key.code) {
                    case sf::Keyboard::W:
                        playerVelocity.y = -playerSpeed;
                        break;
                    case sf::Keyboard::S:
                        playerVelocity.y = playerSpeed;
                        break;
                    case sf::Keyboard::A:
                        playerVelocity.x = -playerSpeed;
                        break;
                    case sf::Keyboard::D:
                        playerVelocity.x = playerSpeed;
                        break;
                    default:
                        break; // Ignore other keys
                }
            }
            else if (event.type == sf::Event::KeyReleased) {
                switch (event.key.code) {
                    case sf::Keyboard::W:
                    case sf::Keyboard::S:
                        playerVelocity.y = 0;
                        break;
                    case sf::Keyboard::A:
                    case sf::Keyboard::D:
                        playerVelocity.x = 0;
                        break;
                    default:
                        break; // Ignore other keys
                }
            }
        }
    }
}

void Game::initializePauseMenu() {
    // Pause menu background
    pauseMenu.setSize(sf::Vector2f(400, 500));
    pauseMenu.setPosition(200, 50);
    pauseMenu.setFillColor(sf::Color(0, 0, 0, 200));
    pauseMenu.setOutlineThickness(2);
    pauseMenu.setOutlineColor(sf::Color::White);

    // Title
    pauseTitleText.setFont(font);
    pauseTitleText.setString(L"пауза");
    pauseTitleText.setCharacterSize(40);
    pauseTitleText.setFillColor(sf::Color::White);
    pauseTitleText.setPosition(
        pauseMenu.getPosition().x + pauseMenu.getSize().x/2 - pauseTitleText.getGlobalBounds().width/2,
        pauseMenu.getPosition().y + 20
    );

    // Buttons
    float buttonWidth = 300;
    float buttonHeight = 50;
    float buttonSpacing = 20;
    float startY = pauseMenu.getPosition().y + 100;

    // Resume button
    resumeButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
    resumeButton.setPosition(pauseMenu.getPosition().x + 50, startY);
    resumeButton.setFillColor(sf::Color(70, 130, 180));
    resumeButton.setOutlineThickness(2);
    resumeButton.setOutlineColor(sf::Color::White);

    resumeText.setFont(font);
    resumeText.setString(L"продолжить");
    resumeText.setCharacterSize(30);
    resumeText.setFillColor(sf::Color::White);
    resumeText.setPosition(
        resumeButton.getPosition().x + buttonWidth/2 - resumeText.getGlobalBounds().width/2,
        resumeButton.getPosition().y + buttonHeight/2 - resumeText.getGlobalBounds().height/2
    );

    // Restart button
    restartButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
    restartButton.setPosition(pauseMenu.getPosition().x + 50, startY + buttonHeight + buttonSpacing);
    restartButton.setFillColor(sf::Color(70, 130, 180));
    restartButton.setOutlineThickness(2);
    restartButton.setOutlineColor(sf::Color::White);

    restartText.setFont(font);
    restartText.setString(L"Заново");
    restartText.setCharacterSize(30);
    restartText.setFillColor(sf::Color::White);
    restartText.setPosition(
        restartButton.getPosition().x + buttonWidth/2 - restartText.getGlobalBounds().width/2,
        restartButton.getPosition().y + buttonHeight/2 - restartText.getGlobalBounds().height/2
    );

    // Main menu button
    mainMenuButton.setSize(sf::Vector2f(buttonWidth, buttonHeight));
    mainMenuButton.setPosition(pauseMenu.getPosition().x + 50, startY + (buttonHeight + buttonSpacing) * 2);
    mainMenuButton.setFillColor(sf::Color(70, 130, 180));
    mainMenuButton.setOutlineThickness(2);
    mainMenuButton.setOutlineColor(sf::Color::White);

    mainMenuText.setFont(font);
    mainMenuText.setString(L"выход");
    mainMenuText.setCharacterSize(30);
    mainMenuText.setFillColor(sf::Color::White);
    mainMenuText.setPosition(
        mainMenuButton.getPosition().x + buttonWidth/2 - mainMenuText.getGlobalBounds().width/2,
        mainMenuButton.getPosition().y + buttonHeight/2 - mainMenuText.getGlobalBounds().height/2
    );
}

void Game::handlePauseEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (resumeButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            togglePause();
        }
        else if (restartButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            // Перезапуск игры
            window.close();
            Game game(gameDifficulty, currentMap, username, initialSelectedCharacter);
            game.run();
        }
        else if (mainMenuButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            // Сохраняем текущие настройки перед возвратом в главное меню
            AuthWindow::musicVolume = 0.0f; // Устанавливаем громкость на 0
            AuthWindow::effectsVolume = effectsVolume;
            AuthWindow::currentTrack = AuthWindow::currentTrack; // Сохраняем текущий трек
            AuthWindow::isMusicPlaying = true;
            AuthWindow::isDarkTheme = AuthWindow::isDarkTheme; // Сохраняем текущую тему
            
            window.close();
            AuthWindow mainMenu;
            mainMenu.setState(WindowState::MAIN_MENU);
            mainMenu.run();
        }
    }
}

void Game::drawPauseMenu() {
    window.draw(pauseMenu);
    window.draw(pauseTitleText);
    window.draw(resumeButton);
    window.draw(resumeText);
    window.draw(restartButton);
    window.draw(restartText);
    window.draw(mainMenuButton);
    window.draw(mainMenuText);
}

void Game::togglePause() {
    isPaused = !isPaused;
    if (isPaused) {
        backgroundMusic.pause();
    } else {
        backgroundMusic.play();
    }
}

void Game::initializeGameOverWindow() {
    // Game over window background
    gameOverWindow.setSize(sf::Vector2f(400, 300));
    gameOverWindow.setPosition(window.getSize().x/2 - 200, window.getSize().y/2 - 150);
    gameOverWindow.setFillColor(sf::Color(0, 0, 0, 230));
    gameOverWindow.setOutlineThickness(2);
    gameOverWindow.setOutlineColor(sf::Color::White);

    // Title
    gameOverTitle.setFont(font);
    gameOverTitle.setCharacterSize(40);
    gameOverTitle.setFillColor(sf::Color::White);
    gameOverTitle.setPosition(
        gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTitle.getGlobalBounds().width/2,
        gameOverWindow.getPosition().y + 20
    );

    // Time text
    gameOverTime.setFont(font);
    gameOverTime.setCharacterSize(30);
    gameOverTime.setFillColor(sf::Color::White);
    gameOverTime.setPosition(
        gameOverWindow.getPosition().x + gameOverWindow.getSize().x/2 - gameOverTime.getGlobalBounds().width/2,
        gameOverWindow.getPosition().y + 100
    );

    // Restart button
    restartGameButton.setSize(sf::Vector2f(300, 50));
    restartGameButton.setPosition(gameOverWindow.getPosition().x + 50, gameOverWindow.getPosition().y + 160);
    restartGameButton.setFillColor(sf::Color(70, 130, 180));
    restartGameButton.setOutlineThickness(2);
    restartGameButton.setOutlineColor(sf::Color::White);

    restartGameText.setFont(font);
    restartGameText.setString(L"Начать заново");
    restartGameText.setCharacterSize(30);
    restartGameText.setFillColor(sf::Color::White);
    restartGameText.setPosition(
        restartGameButton.getPosition().x + restartGameButton.getSize().x/2 - restartGameText.getGlobalBounds().width/2,
        restartGameButton.getPosition().y + restartGameButton.getSize().y/2 - restartGameText.getGlobalBounds().height/2
    );

    // Main menu button
    gameOverMainMenuButton.setSize(sf::Vector2f(300, 50));
    gameOverMainMenuButton.setPosition(gameOverWindow.getPosition().x + 50, gameOverWindow.getPosition().y + 220);
    gameOverMainMenuButton.setFillColor(sf::Color(70, 130, 180));
    gameOverMainMenuButton.setOutlineThickness(2);
    gameOverMainMenuButton.setOutlineColor(sf::Color::White);

    gameOverMainMenuText.setFont(font);
    gameOverMainMenuText.setString(L"Главное меню");
    gameOverMainMenuText.setCharacterSize(30);
    gameOverMainMenuText.setFillColor(sf::Color::White);
    gameOverMainMenuText.setPosition(
        gameOverMainMenuButton.getPosition().x + gameOverMainMenuButton.getSize().x/2 - gameOverMainMenuText.getGlobalBounds().width/2,
        gameOverMainMenuButton.getPosition().y + gameOverMainMenuButton.getSize().y/2 - gameOverMainMenuText.getGlobalBounds().height/2
    );
}

void Game::drawGameOverWindow() {
    window.draw(gameOverWindow);
    window.draw(gameOverTitle);
    window.draw(gameOverTime);
    window.draw(restartGameButton);
    window.draw(restartGameText);
    window.draw(gameOverMainMenuButton);
    window.draw(gameOverMainMenuText);
}

void Game::handleGameOverEvents(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2i mousePos = sf::Mouse::getPosition(window);
        
        if (restartGameButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            window.close();
            Game game(gameDifficulty, currentMap, username, initialSelectedCharacter);
            game.run();
        }
        else if (gameOverMainMenuButton.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            // Сохраняем текущие настройки перед возвратом в главное меню
            AuthWindow::musicVolume = 0.0f; // Устанавливаем громкость на 0
            AuthWindow::effectsVolume = effectsVolume;
            AuthWindow::currentTrack = AuthWindow::currentTrack; // Сохраняем текущий трек
            AuthWindow::isMusicPlaying = true;
            AuthWindow::isDarkTheme = AuthWindow::isDarkTheme; // Сохраняем текущую тему
            
            window.close();
            AuthWindow mainMenu;
            mainMenu.setState(WindowState::MAIN_MENU);
            mainMenu.run();
        }
    }
}

#include "Key.hpp"
#include <iostream>

Key::Key(const sf::Texture& texture) :
    collected(false), rotation(0), animationTime(0), currentFrame(0), initialPosition(0, 0) {
    
    sprite.setTexture(texture);
    sprite.setOrigin(sprite.getLocalBounds().width / 2, sprite.getLocalBounds().height / 2);
}

void Key::update() {
    if (!collected) {
        // Rotate the key
        // rotation += 2.0f; // Increased rotation speed slightly for better visibility
        // sprite.setRotation(rotation);
        
        // Add floating animation
        animationTime += 0.07f; // Adjust speed of floating
        float floatingHeight = 10.0f; // Adjust height of floating
        float yOffset = std::sin(animationTime) * floatingHeight;
        
        // Set sprite position relative to initial position with offset
        sprite.setPosition(initialPosition.x, initialPosition.y + yOffset);
    }
}

void Key::draw(sf::RenderWindow& window) const {
    if (!collected) {
        window.draw(sprite);
    }
}

void Key::collect() {
    collected = true;
}

void Key::setPosition(float x, float y) {
    initialPosition.x = x; // Store initial position
    initialPosition.y = y;
    sprite.setPosition(initialPosition); // Set initial sprite position
}

bool Key::isCollected() const {
    return collected;
}

sf::FloatRect Key::getGlobalBounds() const {
    return sprite.getGlobalBounds();
}

void Key::updateAnimation() {
    // This function is now only used for rotation, size animation removed.
    // The rotation logic is moved to the update() method.
  }

#include "Player.hpp"
#include <iostream>

Player::Player(const sf::Color& color) : 
    velocity(0, 0), speed(100.0f), jumpForce(5.0f), gravity(0.2f), friction(0.7f),
    isJumping(false), health(100), maxHealth(100), invincibilityTime(0), isInvincible(false),
    animationTime(0), currentFrame(0), isMoving(false) {
    
    shape.setSize(sf::Vector2f(15, 15));
    shape.setFillColor(color);
    shape.setOrigin(7.5f, 7.5f);
}

void Player::update() {
    // Apply gravity
    velocity.y += gravity;
    
    // Apply friction
    velocity.x *= friction;
    
    // Update position
    shape.move(velocity);
    
    // Check wall collisions
    checkWallCollisions();
}

void Player::handleInput(const sf::Event& event) {
    if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Space && !isJumping) {
            velocity.y = -jumpForce;
            isJumping = true;
        }
    }
    
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) {
        velocity.x = -speed;
        isMoving = true;
    }
    else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) {
        velocity.x = speed;
        isMoving = true;
    }
    else {
        isMoving = false;
    }
}

void Player::draw(sf::RenderWindow& window) {
    window.draw(shape);
}

void Player::takeDamage(int damage) {
    if (!isInvincible) {
        health -= damage;
        if (health < 0) health = 0;
        isInvincible = true;
        invincibilityTime = 1.0f;
    }
}

void Player::heal(int amount) {
    health += amount;
    if (health > maxHealth) health = maxHealth;
}

sf::Vector2f Player::getPosition() const {
    return shape.getPosition();
}

int Player::getHealth() const {
    return health;
}

void Player::setPosition(float x, float y) {
    shape.setPosition(x, y);
}

void Player::setColor(const sf::Color& color) {
    shape.setFillColor(color);
}

sf::FloatRect Player::getGlobalBounds() const {
    return shape.getGlobalBounds();
}

void Player::checkWallCollisions() {
    sf::FloatRect bounds = shape.getGlobalBounds();
    
    // Check screen boundaries
    if (bounds.left < 0) {
        shape.setPosition(bounds.width / 2, shape.getPosition().y);
        velocity.x = 0;
    }
    else if (bounds.left + bounds.width > 1280) {
        shape.setPosition(1280 - bounds.width / 2, shape.getPosition().y);
        velocity.x = 0;
    }
    
    if (bounds.top < 0) {
        shape.setPosition(shape.getPosition().x, bounds.height / 2);
        velocity.y = 0;
    }
    else if (bounds.top + bounds.height > 800) {
        shape.setPosition(shape.getPosition().x, 800 - bounds.height / 2);
        velocity.y = 0;
        isJumping = false;
    }
}

void Player::updateAnimation() {
    if (isMoving) {
        animationTime += 0.016f;
        if (animationTime >= 0.1f) {
            animationTime = 0;
            currentFrame = (currentFrame + 1) % 4;
            
            int frameWidth = shape.getSize().x / 4;
            shape.setTextureRect(sf::IntRect(currentFrame * frameWidth, 0, 
                                            frameWidth, shape.getSize().y));
        }
    } else {
        currentFrame = 0;
        int frameWidth = shape.getSize().x / 4;
        shape.setTextureRect(sf::IntRect(0, 0, frameWidth, shape.getSize().y));
    }
}

void Player::setSize(const sf::Vector2f& size) {
    shape.setSize(size);
}

void Player::setFillColor(const sf::Color& color) {
    shape.setFillColor(color);
}

void Player::move(float x, float y) {
    shape.move(x, y);
}

void Player::move(const sf::Vector2f& offset) {
    shape.move(offset);
}

#include "AuthWindow.hpp"

int main() {
    AuthWindow authWindow;
    authWindow.run();
    return 0;
}

#include "Trap.hpp"
#include <iostream>

Trap::Trap(const sf::Texture& texture, int damageAmount) :
    active(false), damage(damageAmount), animationTime(0), currentFrame(0) {
    
    sprite.setTexture(texture);
    sprite.setOrigin(sprite.getLocalBounds().width / 2, sprite.getLocalBounds().height / 2); // Set origin to center
    
    // Initial calculation of collision bounds (can be refined later)
    // Assuming the visible part of the monster is a central portion of the texture
    float monsterWidth = sprite.getLocalBounds().width * 0.017f; // Further reduce factor
    float monsterHeight = sprite.getLocalBounds().height * 0.01f; // Further reduce factor
    
    collisionBounds.width = monsterWidth;
    collisionBounds.height = monsterHeight;
}  

void Trap::update() {
    // Traps are static for now, no animation/movement needed.
    // If any trap-specific animation is added later, it will go here.
}

void Trap::draw(sf::RenderWindow& window) const {
    // Draw trap regardless of 'active' status, active is for dealing damage
    window.draw(sprite);
}

void Trap::activate() {
    active = true;
}

void Trap::deactivate() {
    active = false;
}

void Trap::setPosition(float x, float y) {
    sprite.setPosition(x, y);
    
    // Update collision bounds position relative to sprite position
    // Center the collision bounds around the sprite's origin
    collisionBounds.left = sprite.getPosition().x - collisionBounds.width / 2;
    collisionBounds.top = sprite.getPosition().y - collisionBounds.height / 2;
}

bool Trap::isActive() const {
    return active;
}

sf::FloatRect Trap::getGlobalBounds() const {
    return collisionBounds; // Return the custom collision bounds
}

int Trap::getDamage() const {
    return damage;
}

// Removed updateAnimation function as it's no longer used for size pulsing
/*
void Trap::updateAnimation() {
    animationTime += 0.016f;
    if (animationTime >= 0.1f) {
        animationTime = 0;
        currentFrame = (currentFrame + 1) % 4;
        
        float size = 30.0f * (1.0f + 0.1f * std::sin(animationTime * 10.0f));
        shape.setSize(sf::Vector2f(size, size));
        shape.setOrigin(size/2, size/2);
    }
}
*/

#include "User.hpp"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iostream>

const std::string User::USERS_FILE = "users.txt";
const std::string User::SALT = "game_salt";

std::string User::hashPassword(const std::string& password) {
    std::string salted = password + SALT;
    std::string hashed;
    for (char c : salted) {
        hashed += std::to_string(static_cast<int>(c * 31));
    }
    return hashed;
}

void User::saveUserData(const std::string& username, const std::string& password) {
    std::ofstream file(USERS_FILE, std::ios::app);
    if (file.is_open()) {
        file << username << ":" << hashPassword(password) << "\n";
        file.close();
        std::cout << "User data saved: " << username << std::endl;
    } else {
        std::cerr << "Failed to open users file for writing: " << USERS_FILE << std::endl;
    }
}

bool User::loadUserData(const std::string& username, const std::string& password) {
    std::ifstream file(USERS_FILE);
    if (!file.is_open()) {
        std::cerr << "Failed to open users file for reading: " << USERS_FILE << std::endl;
        return false;
    }

    std::string line;
    std::string hashedPassword = hashPassword(password);
    
    std::cout << "Looking for user: " << username << std::endl;
    
    while (std::getline(file, line)) {
        size_t pos = line.find(':');
        if (pos != std::string::npos) {
            std::string storedUsername = line.substr(0, pos);
            std::string storedPassword = line.substr(pos + 1);
            
            std::cout << "Found user in file: " << storedUsername << std::endl;
            
            if (storedUsername == username && storedPassword == hashedPassword) {
                file.close();
                std::cout << "Login successful for: " << username << std::endl;
                return true;
            }
        }
    }
    
    file.close();
    std::cout << "Login failed for: " << username << std::endl;
    return false;
}

bool User::registerUser(const std::string& username, const std::string& password) {
    if (username.empty() || password.empty()) {
        std::cout << "Registration failed: Empty username or password" << std::endl;
        return false;
    }
    
    std::ifstream file(USERS_FILE);
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            size_t pos = line.find(':');
            if (pos != std::string::npos && line.substr(0, pos) == username) {
                file.close();
                std::cout << "Registration failed: Username already exists" << std::endl;
                return false;
            }
        }
        file.close();
    } else {
        std::cout << "Users file does not exist, will create new file" << std::endl;
    }
    
    saveUserData(username, password);
    std::cout << "Registration successful for: " << username << std::endl;
    return true;
}

bool User::loginUser(const std::string& username, const std::string& password) {
    return loadUserData(username, password);
}

